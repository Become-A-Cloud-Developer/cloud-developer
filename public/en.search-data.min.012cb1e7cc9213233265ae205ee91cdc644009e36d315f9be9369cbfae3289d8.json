[{"id":0,"href":"/docs/exercises/1.-presentation-layer/1.-hello-world/","title":"1. Hello World","section":"1. Presentation Layer","content":" Create the app\ndotnet new mvc dotnet new gitignore Run the app\ndotnet run Prepare the app for git\ndotnet new gitignore git init git add . git commit -m \u0026#34;Create MVC webapp\u0026#34; Use VS Code to publish the repository to Github. After that you can push commits with:\ngit push "},{"id":1,"href":"/docs/exercises/1.-presentation-layer/2.-create-a-form-using-basic-html/","title":"2. Create A Form With Basic HTML","section":"1. Presentation Layer","content":" Goal # Create a basic HTML form that collects name and email and submits it via POST. This step introduces fundamental form handling in an ASP.NET Core MVC web application without using advanced features like model binding or validation.\nLearning Objectives # By the end of this exercise, you will:\nUnderstand how to create an HTML form with basic input fields. Learn how to submit form data using an HTTP POST request. Implement a controller to handle form display and submission. Display submitted data in the application console. Step-by-Step Instructions # Step 1: Create a Controller # Navigate to the Controllers folder and create a new file named NewsletterController.cs. Add action methods to display the form and handle form submission. File: Controllers/NewsletterController.cs\nusing Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { // GET: /Newsletter/Subscribe public IActionResult Subscribe() { return View(); } // POST: /Newsletter/Subscribe [HttpPost] public IActionResult Subscribe(string name, string email) { // Add subscription logic here // ... // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {name} Email: {email}\u0026#34;); // Send a message to the user return Content($\u0026#34;Thank you {name} for subscribing to our newsletter!\u0026#34;); } } üí° Information\nThe ‚ÄùGet‚Äù Subscribe() method renders the page with the form. The ‚ÄùPost\u0026quot;¬†Subscribe() method handles the form submission and returns a simple message. Step 2: Create the Form View # Navigate to the Views/Newsletter/ folder. Create a new file named Subscribe.cshtml. Add the following HTML code for the form: File: Views/Newsletter/Subscribe.cshtml\n@{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Sign up for our newsletter\u0026#34;; } \u0026lt;h2\u0026gt;Signup up for our newsletter\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/Newsletter/Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; üí° Information\nThis form submits data to /Newsletter/Signup¬†via HTTP POST. When the form is submitted, the following data is sent back to the server via POST: name: The user\u0026rsquo;s entered name. email: The user\u0026rsquo;s entered email address. It is the name attribute (name=\u0026ldquo;email\u0026rdquo;) in the form input field that is sent back to the server. The id attribute is used within the browser page for linking labels to input fields. Final Tests # Step 1: Run the Application # Start the application:\ndotnet run Then open the browser and navigate to:\nhttp://localhost:\u0026lt;PORT\u0026gt;/Newsletter/Subscribe Change the port to what you have\n‚úÖ Expected Result\nYou should see your form page Step 2: Fill Out and Submit the Form # Enter a name and an incorrect email (without @)\nClick Sign Up.\nEnter a name and a correct email\nClick Sign Up\n‚úÖ Expected Result\nThe incorrect email should show an information message\nUpon correct submission, the browser should display:\nThank you [entered name] for subscribing to our newsletter! In the application console, you should see:\nNew subscription - Name: [Your Name], Email: [Your Email] You have a form! üöÄ # "},{"id":2,"href":"/docs/exercises/1.-presentation-layer/3.-implement-helper-tags-and-model-binding/","title":"3. Helper Tags and Model Binding","section":"1. Presentation Layer","content":" Goal # Enhance the existing form by introducing ASP.NET Core helper tags, model binding (without annotations), and ViewBag for feedback messages.\nLearning Objectives # By the end of this exercise, you will:\nUse ASP.NET Core Tag Helpers (asp-for, asp-action) Implement model binding without validation attributes Utilize ViewBag to display feedback messages after form submission Step-by-Step Instructions # Step 1: Create a Model for Form Data # Navigate to the Models folder and create a new file named Subscriber.cs. Define a simple class with Name and Email properties. Models/Subscriber.cs\nnamespace CloudSoft.Models; public class Subscriber { public string? Name { get; set; } public string? Email { get; set; } } Information\nThis model will store the form input values and be used for model binding in the controller.\nStep 2: Update the Controller # Open NewsletterController.cs in the Controllers folder. Modify the Subscribe action to accept a Subscriber model and store feedback in ViewBag. Controllers/NewsletterController.cs\nusing CloudSoft.Models; using Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { [HttpGet] public IActionResult Subscribe() { return View(); } [HttpPost] public IActionResult Subscribe(Subscriber subscriber) { // Add subscription logic here // ... // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {subscriber.Name} Email: {subscriber.Email}\u0026#34;); // Send a message to the user ViewBag.Message = $\u0026#34;Thank you for subscribing, {subscriber.Name}!\u0026#34;; // Return the view return View(); } } Information\nThe Subscribe method now accepts a Subscriber model, allowing model binding to populate properties automatically. ViewBag.Message stores feedback that can be displayed in the view. Step 3: Update the View to Use Tag Helpers and Display Feedback # Open Views/Newsletter/Subscribe.cshtml. Modify the form to use Tag Helpers and display the feedback message. Views/Newsletter/Subscribe.cshtml\n@model CloudSoft.Models.Subscriber @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Newsletter Signup\u0026#34;; } \u0026lt;h2\u0026gt;Newsletter Signup\u0026lt;/h2\u0026gt; @if (ViewBag.Message != null) { \u0026lt;p style=\u0026#34;color: green;\u0026#34;\u0026gt;@ViewBag.Message\u0026lt;/p\u0026gt; } \u0026lt;form asp-action=\u0026#34;Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Name\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;label asp-for=\u0026#34;Email\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Email\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; Information\n@model CloudSoft.Models.Subscriber tells the view what model to use. ViewBag.Message is displayed after a successful submission. The asp-action helper automatically sets the form action to Subscribe. The asp-for Tag Helpers bind input fields directly to the Subscriber model. Step 4: Update the NavBar # The layout defines the shared structure of your application.\nOpen the _Layout.cshtml file in the Views/Shared folder. Add a navigation link to the Newsletter Subscription feature: Views/Shared/_Layout.cshtml\n\u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-controller=\u0026#34;Newsletter\u0026#34; asp-action=\u0026#34;Subscribe\u0026#34;\u0026gt;Subscribe\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Fill out the form and submit it.\nEnsure the page reloads and displays a confirmation message.\nShout Out! üéâ # Great job implementing Tag Helpers and Model Binding! Next, we\u0026rsquo;ll enhance validation to improve user experience. üöÄ\n"},{"id":3,"href":"/docs/exercises/1.-presentation-layer/4.-client-side-validation-with-data-annotations/","title":"4. Data Annotations and Client-Side Validation","section":"1. Presentation Layer","content":" Goal # Enhance the existing form by introducing data annotations for client-side validation to improve user experience and enforce input constraints.\nLearning Objectives # By the end of this exercise, you will:\nUse data annotations ([Required], [EmailAddress], [StringLength]) Enable client-side validation using ASP.NET Core built-in validation Improve form feedback with validation messages Step-by-Step Instructions # Step 1: Update the Model with Data Annotations # Open Subscriber.cs in the Models folder. Add validation attributes to enforce required fields and format constraints. Models/Subscriber.cs\nusing System.ComponentModel.DataAnnotations; namespace CloudSoft.Models; public class Subscriber { [Required] [StringLength(20, ErrorMessage = \u0026#34;Name cannot exceed 20 characters\u0026#34;)] public string? Name { get; set; } [Required] [EmailAddress] public string? Email { get; set; } } Information\n[Required] ensures the field must be filled. [StringLength] limits the length of the Name field. [EmailAddress] ensures a valid email format. Step 2: Update the View to Display Validation Messages # Open Views/Newsletter/Subscribe.cshtml. Add validation messages for form fields. Views/Newsletter/Subscribe.cshtml\n@model CloudSoft.Models.Subscriber @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Newsletter Signup\u0026#34;; } \u0026lt;h2\u0026gt;Newsletter Signup\u0026lt;/h2\u0026gt; @if (ViewBag.Message != null) { \u0026lt;p style=\u0026#34;color: green;\u0026#34;\u0026gt;@ViewBag.Message\u0026lt;/p\u0026gt; } \u0026lt;form asp-action=\u0026#34;Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Name\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Name\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Email\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Email\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Email\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; @section Scripts { \u0026lt;partial name=\u0026#34;_ValidationScriptsPartial\u0026#34; /\u0026gt; } Information\nThe asp-validation-for displays validation errors next to fields. _ValidationScriptsPartial enables client-side validation using jQuery. Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Try submitting the form with missing or invalid data.\nEnsure error messages appear and prevent submission.\nFill in valid data and confirm successful submission.\nShout Out! üéâ # Fantastic job! You\u0026rsquo;ve successfully added data validation and client-side validation üöÄ\n"},{"id":4,"href":"/docs/exercises/1.-presentation-layer/5.-server-side-validation/","title":"5. Server-Side Validation and Improved Feedback","section":"1. Presentation Layer","content":" Goal # Enhance the form by introducing server-side validation, managing a list of subscribers, and improving feedback handling using TempData and model-level errors.\nLearning Objectives # By the end of this exercise, you will:\nImplement server-side validation for better security. Store subscribers in a list within the controller. Use regular expressions to validate email format. Prevent duplicate email signups. Replace ViewBag with TempData for better feedback persistence. Use ModelState.AddModelError to improve error handling. Step-by-Step Instructions # Step 1: Update the Model with Server-Side Validation # Open Subscriber.cs in the Models folder. Improve client-side email validation using regular expressions. Models/Subscriber.cs\nusing System.ComponentModel.DataAnnotations; namespace CloudSoft.Models; public class Subscriber { [Required] [StringLength(20, ErrorMessage = \u0026#34;Name cannot exceed 20 characters\u0026#34;)] public string? Name { get; set; } [Required] [EmailAddress] [RegularExpression(\u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\u0026#34;, ErrorMessage = \u0026#34;Missing top level domain\u0026#34;)] public string? Email { get; set; } } Information # The RegularExpression attribute enforces stricter email format validation. This prevents malformed or suspicious email input. Step 2: Update the Controller to Store Subscribers and Prevent Duplicates # Open NewsletterController.cs. Modify the Subscribe method to check for duplicate emails and store data in memory. Controllers/NewsletterController.cs\nusing System.Text.RegularExpressions; using CloudSoft.Models; using Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { // Create a \u0026#34;database\u0026#34; of subscribers for demonstration purposes private static List\u0026lt;Subscriber\u0026gt; _subscribers = []; [HttpGet] public IActionResult Subscribe() { return View(); } [HttpPost] public IActionResult Subscribe(Subscriber subscriber) { // Validate the model if (!ModelState.IsValid) { return View(subscriber); } // Check if the email is already subscribed and return a general model level error if (_subscribers.Any(s =\u0026gt; s.Email == subscriber.Email)) { ModelState.AddModelError(\u0026#34;Email\u0026#34;, \u0026#34;The email is already subscribed. Please use a different email.\u0026#34;); return View(subscriber); } // Add the subscriber to the list _subscribers.Add(subscriber); // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {subscriber.Name} Email: {subscriber.Email}\u0026#34;); // Send a message to the user TempData[\u0026#34;SuccessMessage\u0026#34;] = $\u0026#34;Thank you for subscribing, {subscriber.Name}! You will receive our newsletter at {subscriber.Email}\u0026#34;; // Return the view (using the POST-REDIRECT-GET pattern) return RedirectToAction(nameof(Subscribe)); // use nameof() to find the action by name during compile time } } Information\n_subscribers list stores all registered users in memory. Checks if the email already exists before allowing submission. Uses ModelState.AddModelError for field-specific error messages. TempData replaces ViewBag for better feedback persistence across redirects. Step 3: Update the View to Display Errors and TempData Feedback # Open Views/Newsletter/Subscribe.cshtml. Modify the form to display server-side validation errors and TempData messages. Views/Newsletter/Subscribe.cshtml\n@model CloudSoft.Models.Subscriber @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Newsletter Signup\u0026#34;; } \u0026lt;h2\u0026gt;Newsletter Signup\u0026lt;/h2\u0026gt; \u0026lt;!-- Display validation summary for model-level errors --\u0026gt; @if (!ViewData.ModelState.IsValid) { \u0026lt;div class=\u0026#34;alert alert-danger alert-dismissible fade show\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; @Html.ValidationSummary(false, null, new { @class = \u0026#34;text-danger\u0026#34; }) \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn-close\u0026#34; data-bs-dismiss=\u0026#34;alert\u0026#34; aria-label=\u0026#34;Close\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-times\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;!-- Display message from the TempData sent by the controller --\u0026gt; @if (TempData[\u0026#34;SuccessMessage\u0026#34;] != null) { \u0026lt;div class=\u0026#34;alert alert-success alert-dismissible fade show\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; @TempData[\u0026#34;SuccessMessage\u0026#34;] \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn-close\u0026#34; data-bs-dismiss=\u0026#34;alert\u0026#34; aria-label=\u0026#34;Close\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-times\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;form asp-action=\u0026#34;Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Name\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Name\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Email\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Email\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Email\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-3\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; @section Scripts { \u0026lt;partial name=\u0026#34;_ValidationScriptsPartial\u0026#34; /\u0026gt; } Information # TempData message is displayed when redirecting after a successful submission. asp-validation-for displays field-specific validation errors. _ValidationScriptsPartial enables client-side validation. Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Try submitting invalid or empty input and confirm error messages.\nTry registering with the same email twice and confirm the duplicate warning.\nSubmit valid data and check if feedback persists correctly using TempData.\nShout Out! üéâ # Awesome work! You\u0026rsquo;ve implemented server-side validation, handled duplicate entries, and improved feedback management. üöÄ\n"},{"id":5,"href":"/docs/exercises/2.-service-layer/1.-implement-service-layer/","title":"1. Implement Service Layer","section":"2. Service Layer","content":"title = \u0026ldquo;1. Implement Service Layer\u0026rdquo; weight = 1 date = 2025-02-16 draft = true +++\nGoal # Refactor the newsletter functionality by implementing a service layer with dependency injection and async operations.\nLearning Objectives # By the end of this exercise, you will:\nCreate an interface and service implementation Implement dependency injection in ASP.NET Core Use the Result pattern for operation outcomes Work with async/await patterns Understand service lifetimes in ASP.NET Core Step-by-Step Instructions # Step 1: Create the Operation Result Pattern # Create a new class OperationResult.cs in the Models folder Implement the Result pattern for handling operation outcomes Models/OperationResult.cs\nnamespace CloudSoft.Models; public class OperationResult { public bool IsSuccess { get; private set; } public string Message { get; private set; } private OperationResult(bool success, string message) { IsSuccess = success; Message = message; } public static OperationResult Success(string message) =\u0026gt; new(true, message); public static OperationResult Failure(string message) =\u0026gt; new(false, message); } üí° Information\nThe Result pattern provides:\nA standardized way to handle operation outcomes Clear separation between success and failure cases Immutable results through private setters Factory methods for creating results Consistent messaging across the application Step 2: Create the Newsletter Service Interface # Create a new interface INewsletterService.cs in the Services folder Define the contract for newsletter operations Services/INewsletterService.cs\nusing CloudSoft.Models; namespace CloudSoft.Services; public interface INewsletterService { Task\u0026lt;OperationResult\u0026gt; SignUpForNewsletterAsync(Subscriber subscriber); Task\u0026lt;OperationResult\u0026gt; OptOutFromNewsletterAsync(string email); Task\u0026lt;IEnumerable\u0026lt;Subscriber\u0026gt;\u0026gt; GetActiveSubscribersAsync(); } üí° Information\nInterfaces provide:\nA contract for implementation Dependency inversion principle Easier testing through mocking Clear separation of concerns Using Task enables:\nAsynchronous operations Non-blocking execution Better scalability Future-proofing for database operations Step 3: Implement the Newsletter Service # Create a new class NewsletterService.cs in the Services folder Implement the interface with async operations Services/NewsletterService.cs\nusing CloudSoft.Models; namespace CloudSoft.Services; public class NewsletterService : INewsletterService { // Simulate a database for storing subscribers private static readonly List\u0026lt;Subscriber\u0026gt; _subscribers = []; public async Task\u0026lt;OperationResult\u0026gt; SignUpForNewsletterAsync(Subscriber subscriber) { // Simulate a long running operation return await Task.Run(() =\u0026gt; { // Check subscriber is not null and has a valid email if (subscriber == null || string.IsNullOrWhiteSpace(subscriber.Email)) { return OperationResult.Failure(\u0026#34;Invalid subscriber information.\u0026#34;); } // Check if the email is already subscribed if (IsAlreadySubscribed(subscriber.Email)) { return OperationResult.Failure(\u0026#34;You are already subscribed to our newsletter.\u0026#34;); } // Add the subscriber to the list _subscribers.Add(subscriber); // Return a success message return OperationResult.Success($\u0026#34;Welcome to our newsletter, {subscriber.Name}! You\u0026#39;ll receive updates soon.\u0026#34;); }); } public async Task\u0026lt;OperationResult\u0026gt; OptOutFromNewsletterAsync(string email) { // Simulate a long running operation return await Task.Run(() =\u0026gt; { // Check if the email is valid if (string.IsNullOrWhiteSpace(email)) { return OperationResult.Failure(\u0026#34;Invalid email address.\u0026#34;); } // Find the subscriber by email var subscriber = FindSubscriberByEmail(email); if (subscriber == null) { return OperationResult.Failure(\u0026#34;We couldn\u0026#39;t find your subscription in our system.\u0026#34;); } // Remove the subscriber from the list _subscribers.Remove(subscriber); // Return a success message return OperationResult.Success(\u0026#34;You have been successfully removed from our newsletter. We\u0026#39;re sorry to see you go!\u0026#34;); }); } public async Task\u0026lt;IEnumerable\u0026lt;Subscriber\u0026gt;\u0026gt; GetActiveSubscribersAsync() { // Simulate a long running operation and return the list of subscribers return await Task.Run(() =\u0026gt; _subscribers.ToList()); } private static bool IsAlreadySubscribed(string email) { return _subscribers.Any(s =\u0026gt; s.Email!.Equals(email, StringComparison.OrdinalIgnoreCase)); } private static Subscriber? FindSubscriberByEmail(string email) { return _subscribers.FirstOrDefault(s =\u0026gt; s.Email!.Equals(email, StringComparison.OrdinalIgnoreCase)); } } üí° Information\nTask.Run() is used here because:\nWe\u0026rsquo;re working with in-memory operations In real applications, you\u0026rsquo;d use actual async operations (e.g., database calls) It demonstrates the async pattern structure Prepares the code for future async implementations Step 4: Register the Service # Open Program.cs Add the service registration in the dependency injection container builder.Services.AddScoped\u0026lt;INewsletterService, NewsletterService\u0026gt;(); Program.cs\nusing CloudSoft.Services; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllersWithViews(); ... builder.Services.AddScoped\u0026lt;INewsletterService, NewsletterService\u0026gt;(); ... var app = builder.Build(); üí° Information\nAddScoped means:\nA new instance is created for each HTTP request All components within the same request share the same instance The instance is disposed at the end of the request Other lifetimes include:\nSingleton: One instance for the entire application Transient: New instance every time requested Scoped: New instance per request (what we\u0026rsquo;re using) Step 5: Update the Controller # Update NewsletterController.cs to use dependency injection Modify methods to use async/await Controllers/NewsletterController.cs using CloudSoft.Models; using CloudSoft.Services; using Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { private readonly INewsletterService _newsletterService; public NewsletterController(INewsletterService newsletterService) { // Inject the INewsletterService via the constructor from the DI container _newsletterService = newsletterService; } [HttpGet] public IActionResult Subscribe() { return View(); } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Subscribe(Subscriber subscriber) { // Validate the model if (!ModelState.IsValid) { return View(subscriber); } // Check if the email is already subscribed and return a general model level error var result = await _newsletterService.SignUpForNewsletterAsync(subscriber); if (!result.IsSuccess) { ModelState.AddModelError(\u0026#34;Email\u0026#34;, result.Message); return View(subscriber); } // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {subscriber.Name} Email: {subscriber.Email}\u0026#34;); // Send a message to the user TempData[\u0026#34;SuccessMessage\u0026#34;] = result.Message; // Return the view (using the POST-REDIRECT-GET pattern) return RedirectToAction(nameof(Subscribe)); } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Subscribers() { var subscribers = await _newsletterService.GetActiveSubscribersAsync(); return View(subscribers); } [HttpPost] [ValidateAntiForgeryToken] public async Task\u0026lt;IActionResult\u0026gt; Unsubscribe(string email) { var result = await _newsletterService.OptOutFromNewsletterAsync(email); if (result.IsSuccess) { TempData[\u0026#34;SuccessMessage\u0026#34;] = result.Message; } return RedirectToAction(nameof(Subscribers)); } } Final Tests # Test Service Registration # Run the application Navigate to the Subscribe page Submit a subscription ‚úÖ Expected Result\nApplication starts without errors Subscribe form works Successful subscription shows success message Exercise Done! üéØ # You\u0026rsquo;ve successfully implemented a service layer with modern patterns and practices! üöÄ\n"},{"id":6,"href":"/docs/exercises/2.-service-layer/2.-project-structure-and-unit-tests/","title":"2. Project Structure and Unit Tests","section":"2. Service Layer","content":"title = \u0026ldquo;2. Implement Unit Tests and Organize Solution\u0026rdquo; weight = 2 date = 2025-02-16 draft = true +++\nGoal # Organize the solution with proper project structure and implement unit tests for the service layer.\nLearning Objectives # By the end of this exercise, you will:\nUnderstand .NET solution and project organization Learn how to create and structure test projects Write unit tests using xUnit Use dependency injection in unit tests Work with test assertions and test patterns Step-by-Step Instructions # Step 1: Move the Web project to /src folder # Open a terminal in your project root folder Create a new solution file: Step 1: Create the Solution Structure # Delete the .sln file\nMove the Web project to /src folder\nall files except .gitignore ReadMe.md Open a terminal in your project root folder\nCreate a new solution file:\ndotnet new sln dotnet sln add src/CloudSoft.csproj Run the web project and check it works:\ndotnet run --project src/CloudSoft.csproj üí° Information\nThis creates a clean solution structure with:\nA root solution file Source code under the src folder Clear separation of concerns Step 2: Create the Test Project # Create a new test project in the test folder:\nmkdir tests cd tests dotnet new xunit -n Services.UnitTests dotnet add Services.UnitTests reference ../src/CloudSoft.csproj Add the test project to the solution. Go back to the solution root folder:\ndotnet sln add tests/Services.UnitTests/Services.UnitTests.csproj Add required package references. Go to the test projects root folder:\ndotnet add package Microsoft.NET.Test.Sdk dotnet add package xunit dotnet add package xunit.runner.visualstudio dotnet add package coverlet.collector Go back to the solution root folder and run the example test\ndotnet test üí° Information\nThe test project setup:\nUses xUnit as the testing framework Includes necessary testing tools Links to the main project for testing Follows standard naming conventions Step 3: Create the Newsletter Service Tests # Create a new test class NewsletterServiceTests.cs in the test project: tests/Services.UnitTests/NewsletterServiceTests.cs\nusing CloudSoft.Models; using CloudSoft.Services; namespace CloudSoft.Services.UnitTests; public class NewsletterServiceTests { private readonly INewsletterService _sut; public NewsletterServiceTests() { _sut = new NewsletterService(); } [Fact] public async Task SignUpForNewsletterAsync_WithValidSubscriber_ReturnsSuccess() { // Arrange var subscriber = new Subscriber { Name = \u0026#34;Test User\u0026#34;, Email = \u0026#34;user@example.com\u0026#34; }; // Act var result = await _sut.SignUpForNewsletterAsync(subscriber); // Assert Assert.True(result.IsSuccess); Assert.Contains(\u0026#34;Welcome to our newsletter\u0026#34;, result.Message); } [Fact] public async Task SignUpForNewsletterAsync_WithDuplicateEmail_ReturnsFailure() { // Arrange var subscriber1 = new Subscriber { Name = \u0026#34;Test User 1\u0026#34;, Email = \u0026#34;duplicate@example.com\u0026#34; }; var subscriber2 = new Subscriber { Name = \u0026#34;Test User 2\u0026#34;, Email = \u0026#34;duplicate@example.com\u0026#34; }; await _sut.SignUpForNewsletterAsync(subscriber1); // Act var result = await _sut.SignUpForNewsletterAsync(subscriber2); // Assert Assert.False(result.IsSuccess); Assert.Contains(\u0026#34;already subscribed\u0026#34;, result.Message); } [Fact] public async Task OptOutFromNewsletterAsync_WithExistingEmail_ReturnsSuccess() { // Arrange var subscriber = new Subscriber { Name = \u0026#34;Test User\u0026#34;, Email = \u0026#34;optoutuser@example.com\u0026#34; }; await _sut.SignUpForNewsletterAsync(subscriber); // Act var result = await _sut.OptOutFromNewsletterAsync(\u0026#34;optoutuser@example.com\u0026#34;); // Assert Assert.True(result.IsSuccess); Assert.Contains(\u0026#34;successfully removed\u0026#34;, result.Message); } [Fact] public async Task OptOutFromNewsletterAsync_WithNonexistentEmail_ReturnsFailure() { // Act var result = await _sut.OptOutFromNewsletterAsync(\u0026#34;nonexistent@example.com\u0026#34;); // Assert Assert.False(result.IsSuccess); Assert.Contains(\u0026#34;couldn\u0026#39;t find your subscription\u0026#34;, result.Message); } [Fact] public async Task GetActiveSubscribersAsync_ReturnsAllSubscribers() { // Arrange var subscriber1 = new Subscriber { Name = \u0026#34;Test User 1\u0026#34;, Email = \u0026#34;test1@example.com\u0026#34; }; var subscriber2 = new Subscriber { Name = \u0026#34;Test User 2\u0026#34;, Email = \u0026#34;test2@example.com\u0026#34; }; await _sut.SignUpForNewsletterAsync(subscriber1); await _sut.SignUpForNewsletterAsync(subscriber2); // Act var subscribers = await _sut.GetActiveSubscribersAsync(); // Assert Assert.True(subscribers.Count() \u0026gt;= 2); // At least 2 subscribers. Other tests add subscribers. Assert.Contains(subscribers, s =\u0026gt; s.Email == \u0026#34;test1@example.com\u0026#34;); Assert.Contains(subscribers, s =\u0026gt; s.Email == \u0026#34;test2@example.com\u0026#34;); } } üí° Information\nThe unit tests follow the AAA pattern:\nArrange: Set up the test data Act: Execute the method being tested Assert: Verify the results Each test focuses on a specific scenario and has a clear purpose.\nStep 4: Run the Tests # Run all tests from the command line:\ndotnet test Run tests with coverage:\ndotnet test /p:CollectCoverage=true üí° Information\nThe test runner will:\nExecute all tests in the solution Report test results and failures Generate code coverage metrics (when enabled) Final Tests # Step 1: Verify Solution Structure # Open the solution in Visual Studio Code\nVerify the following structure exists:\nCloudSoft.sln src/ CloudSoft.csproj [other project files] tests/ Services.UnitTests/ Services.UnitTests.csproj NewsletterServiceTests.cs ‚úÖ Expected Result\nClean, organized project structure Solution builds successfully Project references are correctly set up Step 2: Run All Tests # Run the tests using the command line Check the test results ‚úÖ Expected Result\nAll tests pass successfully Step 3: Run Tests with Coverage in VS Code # Run tests with coverage: Open Test Explorer in VS Code (left side bar, E-kolv) Click the \u0026ldquo;Run Tests\u0026rdquo; button with coverage icon (beaker with checkmark) View coverage results in the Test Explorer panel ‚úÖ Expected Result\nTest coverage report shows in VS Code Coverage information highlights tested/untested code Coverage percentage is displayed for each class Exercise Done! üß™ # You\u0026rsquo;ve successfully organized your project and implemented unit tests! üöÄ\n"}]