[{"id":0,"href":"/docs/2.-exercises/1.-presentation-layer/1.-hello-world/","title":"1. Hello World","section":"1. Presentation Layer","content":" Hello World # Create the app\ndotnet new mvc dotnet new gitignore Run the app\ndotnet run Prepare the app for git\ndotnet new gitignore git init git add . git commit -m \u0026#34;Create MVC webapp\u0026#34; Use VS Code to publish the repository to Github. After that you can push commits with:\ngit push "},{"id":1,"href":"/docs/4.-exercises/2.-network/exercise-1---creating-a-virtual-network/","title":"1. Creating a Virtual Network (vNet)","section":"2. Network","content":" Overview # The objective of this exercise is to create a Virtual Network (vNet) with a default subnet using the Azure Portal, laying the foundation for a secure network architecture. You will also provision three servers having the roles Web Server, Reverse Proxy and Bastion Host respectively. Finally, firewall rules will be created to secure the network using Azure Network Security Groups (NSG)\nStep 1: Log in to Azure Portal # Open https://portal.azure.com. Sign in with your Azure account credentials. Step 2: Create a Virtual Network # In the Azure Portal, use the search bar at the top to search for \u0026ldquo;Virtual Networks\u0026rdquo;. Select Virtual Networks from the search results or from the left menu Click the + Create button at the top of the Virtual Networks page. On the Basics tab, fill in the following information: Subscription: Select your subscription. Resource Group: Choose an existing resource group or create a new one (e.g., DemoRG). Name: Enter DemoVNet. Region: Choose a region close to your location (e.g., North Europe). Click Review + Create and then click Create to deploy the Virtual Network. 💡 Information\nA Virtual Network (VNet) is the foundation of a cloud-based network. Subnets allow logical segmentation within the VNet for better security and resource management. The address space 10.0.0.0/16 allows over 65,000 addresses, and subnets divide this range into smaller, manageable blocks (in this case the default subnet 10.0.0.0/24) ✅ Verification Step:\nAfter deployment, return to Virtual Networks in the Azure Portal. Select the DemoVNet from the list of Virtual Networks. Confirm that the following settings are present: Address Space: 10.0.0.0/16. Subnets: default with address range 10.0.0.0/24. Step 2: Provision an Ubuntu VM in the VNet/Subnet (Web Server) # In the Azure Portal, go to \u0026ldquo;Virtual Machines\u0026rdquo; Create a New Virtual Machine Click + Create at the top of the Virtual Machines page.\nSubscription: Select the subscription used in Step 1.\nResource Group: Select the same resource group as before.\nVirtual Machine Name: Enter a name, e.g., WebServer.\nRegion: Use the same region as the VNet.\nImage: Choose Ubuntu Server 24.04 LTS.\nSize: Select a small size, e.g., Standard_B1s.\nAdministrator Account:\nAuthentication Type: Select SSH Public Key. Username: Enter azureuser. SSH Public Key: Generate new key pair. Go to the network tab\nUnder Virtual Network, select the VNet created in Step 1. For Subnet, choose the default subnet created in Step 1. Public IP: Ensure a public IP address is assigned. NIC Network Security Group: Select Basic and allow SSH (port 22). Go to the advanced tab\nUse custom data to install nginx #!/bin/bash apt update apt install nginx -y Click Review + create and then Create.\nStep 3: Configure the Web Server # Login to the WebServer and change the default Nginx page to \u0026ldquo;Welcome World\u0026rdquo;\nRun the following commands to change the port nginx listens to (just for this exercise to show that web servers and app servers can potentially listen to many different ports. 8080 is a very common port to use)\nsudo sed -i \u0026#39;s/listen 80 default_server;/listen 8080 default_server;/\u0026#39; /etc/nginx/sites-available/default sudo sed -i \u0026#39;/listen \\[::\\]:80 default_server;/d\u0026#39; /etc/nginx/sites-available/default sudo nginx -s reload sudo sed -i \u0026#39;s/Welcome to nginx/Hello World/g\u0026#39; /var/www/html/index.nginx-debian.html ✅ Verification Step:\nRun curl and verify output from default page curl localhost:8080 Step 4: Provision another Ubuntu VM in the VNet/Subnet (Reverse Proxy) # Create another identical VM (including installing Nginx) Name it ReverseProxy Step 5: Configure the Reverse Proxy # Login to the ReverseProxy and run\ncurl \u0026lt;PrivateIP_WebServer\u0026gt;:8080 ✅ Verification Step:\nVerify output from default page of the Web Server\n💡 Information\nThere is no firewall between servers in the same network You can also use the private IPs within the same vNet In order to give the Reverse Proxy its role as \u0026ldquo;Reverse Proxy\u0026rdquo; we need to edit the file /etc/nginx/sites-available/default. Replace the content with this (change the Private IP and Port):\nsudo nano /etc/nginx/sites-available/default server { listen 80 default_server; location / { proxy_pass http://\u0026lt;PrivateIP\u0026gt;:\u0026lt;Port\u0026gt;/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } sudo nginx -t sudo nginx -s reload curl localhost ✅ Verification Step:\nVerify output from default page of the Web Server\n💡 Information\nNginx is a very versatile software that beside being used for web servers it is also very often used for reverse proxies.\nStep 6: Provision another Ubuntu VM in the VNet/Subnet (Bastion Host) # Create another identical VM (but don´t install Nginx) Name it BastionHost Step 7: Use the Bastion Host to SSH in to the other servers # Login to the Bastion Host.\nTry to login to the other two servers from here.\n💡 Information\nEach server has its own ssh key. We don´t want to store the keys on the Bastion Host, instead we use an ssh agent to bring the keys to the other servers in memory to the Bastion Host.\nExit the terminal, so that you are back on your laptop\nStart the SSH Agent, on your laptop, and give it the keys:\neval $(ssh-agent) ssh-add ~/Downloads/WebServer_key.pem ssh-add ~/Downloads/ReverseProxy_key.pem ssh-add ~/Downloads/BastionHost_key.pem ssh-add -l SSH Jump via BastionHost using the Agent (-A):\nssh -A azureuser@\u0026lt;BastionHost_IP\u0026gt; Inside the BastionHost, try to SSH into WebServer using its private IP:\nssh -A azureuser@\u0026lt;WebServer_InternalIP\u0026gt; ✅ Verification Step:\nVerify that you could SSH into the Web Server\nStep 8: Secure the solution with NSG (Network Security Groups) # Currently there is one NSG for each NIC of each server. You will find the firewall rules in each NSG under the menu Networking -\u0026gt; Network settings for each VM.\nModify the NSG of the Web Server\nNavigate to the WebServer VM Select the menu Networking -\u0026gt; Network settings Follow the link WebServer-nsg Delete the row with the SSH rule. ✅ Verification Step:\nVerify that you cannot SSH into the Web Server from the Internet Verify that you can SSH into the Web Server from the BastionHost Verify that you cannot browse (HTTP) into the Web Server from the Internet Verify that you can browse (HTTP) into the Web Server from the ReverseProxy Modify the NSG of the Reverse Proxy\nNavigate to the ReverseProxy VM Select the menu Networking -\u0026gt; Network settings Follow the link ReverseProxy-nsg Delete the row with the SSH rule. Select the menu Settings -\u0026gt; Inbound security rules Click + Add In Service, choose HTTP Click Add ✅ Verification Step:\nVerify that you cannot SSH into the Reverse Proxy from the Internet Verify that you can SSH into the Reverse Proxy from the BastionHost Verify that you can browse (HTTP) into the Reverse Proxy from the Internet Verify that you get the page served by the Web Server (Hello World) Conclusion # By completing this exercise, you achieved the following learning outcomes:\nVNet Creation: Established a Virtual Network with a subnet to provide a secure foundation for cloud infrastructure. VM Provisioning: Deployed and configured VMs with specific roles (Web Server, Reverse Proxy, Bastion Host) to simulate a functional network. Nginx Configuration: Explored the use of Nginx as a web server and reverse proxy. Secure Networking: Applied Azure NSGs to enforce access control and secure the environment. SSH Agent Forwarding: Practiced secure internal server management without exposing sensitive credentials. "},{"id":2,"href":"/docs/4.-exercises/1.-virtual-machine/exercise-1---provisioning-a-vm-via-azure-portal-with-username-and-password/","title":"1. Provisioning a VM via Azure Portal","section":"1. Virtual Machine","content":" Overview # This exercise introduces the Azure Portal, guiding you through the creation of a Virtual Machine (VM). You will configure an Ubuntu Linux VM with a username/password for access and verify that the VM is running successfully by logging into the VM from Azure Cloud Shell.\nStep 1: Log in to Azure Portal # Open a web browser and navigate to the Azure Portal. Sign in using your Azure account credentials. Step 2: Create a Resource Group # In the Azure Portal, search for \u0026ldquo;Resource groups\u0026rdquo; in the search bar. Click \u0026ldquo;Create\u0026rdquo; and fill in the following: Subscription: Choose your subscription. Resource Group Name: LabResourceGroup Region: Choose a region (e.g. North Europe). Click Review + Create and then Create. 💡 Information\nA Resource Group is a container that holds related resources for an Azure solution. It allows for easy management and deletion of all resources together.\nStep 3: Create a Virtual Machine # In the Azure Portal, search for \u0026ldquo;Virtual Machines\u0026rdquo; and click \u0026ldquo;Create\u0026rdquo; \u0026gt; \u0026ldquo;Azure Virtual machine\u0026rdquo;.\nConfigure the VM:\nSubscription: Select your subscription. Resource Group: Choose LabResourceGroup. Virtual Machine Name: LabVM Region: Same as the resource group. Zone options: Select Azure-selected zone Image: Select Ubuntu Server 24.04 LTS. Size: Choose a size like Standard_B1s. Authentication Type: Select Password. Username: azureuser Password: Create a secure password and confirm it. Configure inbound ports:\nCheck Allow selected ports and select HTTP (80) and SSH (22). Click Review + Create, and then Create.\n💡 Information\nVM Size: Determines the CPU, memory, and storage capacity. For this exercise, Standard_B1s is cost-effective for learning purposes. Inbound Ports: Ensure HTTP (for web traffic) and SSH (for secure access) are open for connectivity. After clicking Create, Azure will begin provisioning the VM. Once completed, navigate to the Virtual Machines section and locate LabVM.\n✅ Verification Step:\nEnsure the VM status is \u0026ldquo;Running\u0026rdquo; in the Virtual Machines overview.\nStep 4: Connect to the VM Using Azure Cloud Shell # In the Azure Portal, click the Cloud Shell icon (top-right corner)\nSelect Bash as your shell environment\nConnect to your VM via SSH:\nssh azureuser@\u0026lt;VM_Public_IP\u0026gt; Replace \u0026lt;VM_Public_IP\u0026gt; with the public IP address of your VM, found in the Overview tab of the VM. Answer yes on the question: Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 💡 Information:\nSSH (Secure Shell) is a protocol used for secure remote login to your server.\nNote that there is no feedback in the terminal when writing a password. It will look like you don´t write anything\n✅ Verification Step:\nYou should see a command prompt for azureuser@LabVM.\nStep 5: Install Nginx (Optional) # Install Nginx:\nsudo apt update sudo apt install nginx -y 💡 Information\nNginx is a very popular Web Server.\nThe apt update command refreshes the list of available packages. The -y flag confirms the operation without additional prompts (user interaction. sudo is used in order to run commands as administrator.\n✅ Verification Step:\nHere are three ways to verify that the installation of nginx was successfull:\nRun the command sudo systemctl status nginx. Ensure the output shows active (running) for the Nginx service. This means that the program is installed and running. Get back to the prompt by pressing Ctrl-C.\nRun the command curl localhost. Ensure you get som HTML code back. This means that it runs correctly regardless of firewall settings.\nOpen a browser and go to the \u0026lt;VM_Public_IP\u0026gt;. You should see the \u0026ldquo;Welcome to Nginx!\u0026rdquo; default page.\nStep 6: Clean Up Resources (Optional) # In the Azure Portal, navigate to the Resource Groups section by searching for \u0026ldquo;Resource Groups\u0026rdquo; in the search bar.\nLocate the resource group you created, LabResourceGroup. You can use the search bar in the Resource Groups section if you have multiple groups.\nClick on the LabResourceGroup name to open the resource group details.\nIn the resource group overview, click the Delete resource group button at the top of the page.\nA confirmation prompt will appear. Check the Apply force delete \u0026hellip; checkbox and enter the exact name of the resource group, LabResourceGroup, in the confirmation box, and click Delete and then Delete again.\n💡 Information\nDeleting the resource group will permanently remove all resources contained within it, including the virtual machine, network interface, and any associated disks or public IPs. This action helps avoid unnecessary costs and keeps your environment clean.\n✅ Verification Step:\nAfter deletion, go back to the Resource Groups page in the Azure Portal and confirm that LabResourceGroup no longer appears in the list. Refresh the page if necessary. It can take a minute or two before it has finalized the operation.\nExercise Complete! # You have successfully provisioned a Virtual Machine in Azure using the portal and connected to it using Azure Cloud Shell. You also verified its operation by installing and testing the web server Nginx.\n"},{"id":3,"href":"/docs/2.-exercises/1.-presentation-layer/2.-create-a-form-using-basic-html/","title":"2. Create A Form With Basic HTML","section":"1. Presentation Layer","content":" Create A Form With Basic HTML # Goal # Create a basic HTML form that collects name and email and submits it via POST. This step introduces fundamental form handling in an ASP.NET Core MVC web application without using advanced features like model binding or validation.\nLearning Objectives # By the end of this exercise, you will:\nUnderstand how to create an HTML form with basic input fields. Learn how to submit form data using an HTTP POST request. Implement a controller to handle form display and submission. Display submitted data in the application console. Step-by-Step Instructions # Step 1: Create a Controller # Navigate to the Controllers folder and create a new file named NewsletterController.cs. Add action methods to display the form and handle form submission. File: Controllers/NewsletterController.cs\nusing Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { // GET: /Newsletter/Subscribe public IActionResult Subscribe() { return View(); } // POST: /Newsletter/Subscribe [HttpPost] public IActionResult Subscribe(string name, string email) { // Add subscription logic here // ... // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {name} Email: {email}\u0026#34;); // Send a message to the user return Content($\u0026#34;Thank you {name} for subscribing to our newsletter!\u0026#34;); } } 💡 Information\nThe ”Get” Subscribe() method renders the page with the form. The ”Post\u0026quot; Subscribe() method handles the form submission and returns a simple message. Step 2: Create the Form View # Navigate to the Views/Newsletter/ folder. Create a new file named Subscribe.cshtml. Add the following HTML code for the form: File: Views/Newsletter/Subscribe.cshtml\n@{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Sign up for our newsletter\u0026#34;; } \u0026lt;h2\u0026gt;Signup up for our newsletter\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/Newsletter/Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 💡 Information\nThis form submits data to /Newsletter/Signup via HTTP POST. When the form is submitted, the following data is sent back to the server via POST: name: The user\u0026rsquo;s entered name. email: The user\u0026rsquo;s entered email address. It is the name attribute (name=\u0026ldquo;email\u0026rdquo;) in the form input field that is sent back to the server. The id attribute is used within the browser page for linking labels to input fields. Final Tests # Step 1: Run the Application # Start the application:\ndotnet run Then open the browser and navigate to:\nhttp://localhost:\u0026lt;PORT\u0026gt;/Newsletter/Subscribe Change the port to what you have\n✅ Expected Result\nYou should see your form page Step 2: Fill Out and Submit the Form # Enter a name and an incorrect email (without @)\nClick Sign Up.\nEnter a name and a correct email\nClick Sign Up\n✅ Expected Result\nThe incorrect email should show an information message\nUpon correct submission, the browser should display:\nThank you [entered name] for subscribing to our newsletter! In the application console, you should see:\nNew subscription - Name: [Your Name], Email: [Your Email] You have a form! 🚀 # "},{"id":4,"href":"/docs/4.-exercises/2.-network/exercise-2---creating-a-virtual-network-with-enhanced-security/","title":"2. Creating a Virtual Network with Enhanced Security","section":"2. Network","content":" Overview # The objective of this exercise is to create a Virtual Network (vNet) with a subnet secured by a Network Security Group (NSG) attached to the subnet itself. You will also provision three servers with specific roles: Web Server, Reverse Proxy, and Bastion Host. Application Security Groups (ASGs) will be configured for the Reverse Proxy and Bastion Host, and all server configurations will be automated using cloud-init.\nStep 1: Log in to Azure Portal # Open https://portal.azure.com. Sign in with your Azure account credentials. Step 2: Create a Virtual Network # In the Azure Portal, use the search bar at the top to search for \u0026ldquo;Virtual Networks\u0026rdquo;. Select Virtual Networks from the search results or from the left menu Click the + Create button at the top of the Virtual Networks page. On the Basics tab, fill in the following information: Subscription: Select your subscription. Resource Group: Choose an existing resource group or create a new one (e.g., DemoRG). Name: Enter DemoVNet. Region: Choose a region close to your location (e.g., North Europe). Click Review + Create and then click Create to deploy the Virtual Network. Step 3: Create Application Security Groups # In the Azure Portal, search for Application Security Groups.\nCreate two ASGs:\nReverse Proxy:\nName: ReverseProxyASG Resource Group: DemoRG Bastion Host:\nName: BastionHostASG Resource Group: DemoRG Step 4: Create a Network Security Group and Rules # In the Azure Portal, search for Network Security Groups.\nClick + Create and provide the following information:\nName: DemoNSG. Resource Group: Select DemoRG. Region: Choose the same region as the VNet. Got to resource and add inbound security rules:\nGo to Settings -\u0026gt; Inbound security rules SSH:\nSource: Service Tag Source service tag: Internet Destination: Application security group Destination application security group: BastionHostASG Service: SSH Click Add HTTP:\nSource: Service Tag Source service tag: Internet Destination: Application security group Destination application security group: ReverseProxyASG Service: HTTP Click Add Attach the NSG to the default subnet in the VNet.\nGo to Settings -\u0026gt; Subnets Click + Associate and select Virtual network: DemoVNet Subnet: default Step 5: Provision VMs and Configure with Cloud-Init # Create three VMs using the following specifications: VM Names: WebServer, ReverseProxy, BastionHost.\nImage: Ubuntu Server 24.04 LTS.\nSize: Standard_B1s.\nSubnet: Use default.\nPublic IP: Attach only to the Bastion Host and the Reverse Proxy.\nNSG: Leave None for all NICs.\nASG: Attach ReverseProxyASG to the Reverse Proxy and BastionHostASG to the Bastion Host.\nWebServer (cloud-config):\n#cloud-config packages: - nginx write_files: - path: /var/www/html/index.html content: | \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello World!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; - path: /etc/nginx/sites-available/default content: | server { listen 8080 default_server; server_name _; root /var/www/html; index index.html; } runcmd: - systemctl restart nginx ReverseProxy (cloud-config):\n#cloud-config packages: - nginx write_files: - path: /etc/nginx/sites-available/default content: | server { listen 80; location / { proxy_pass http://webserver.internal.cloudapp.net:8080/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } runcmd: - systemctl restart nginx Test and Verify # This chapter ensures the Virtual Network (VNet), Network Security Group (NSG), and Virtual Machines (VMs) are configured correctly and functioning as intended. Follow these steps to verify each aspect of the setup:\n1. Verify NSG Rules # Navigate to the DemoNSG in the Azure Portal. Check the inbound security rules: SSH is allowed only for the BastionHostASG. HTTP traffic is allowed only for the ReverseProxyASG. Confirm that the NSG is associated with the default subnet in the VNet. ✅ Verification Step:\nAttempt SSH access from the Internet to the Web Server or Reverse Proxy. This should fail. Attempt HTTP access to the Web Server directly. This should fail. Attempt HTTP access to the Reverse Proxy. This should succeed. 2. Check Application Security Groups # Ensure the Application Security Groups (ASGs) are correctly associated: ReverseProxyASG is assigned to the Reverse Proxy VM. BastionHostASG is assigned to the Bastion Host VM. ✅ Verification Step:\nNavigate to the Networking section of the Reverse Proxy and Bastion Host VMs. Confirm the ASGs are listed under Application Security Groups. 3. Test HTTP Access to Reverse Proxy # Open a browser or use a tool like curl to access the Reverse Proxy\u0026rsquo;s public IP on port 80. Verify that the Reverse Proxy forwards traffic to the Web Server using its internal DNS name. Command:\ncurl http://\u0026lt;ReverseProxy_PublicIP\u0026gt; Expected Output:\nThe HTTP response displays the content of the Web Server\u0026rsquo;s index.html page with the message: Hello World! 4. Test Internal Communication # Use the Bastion Host to SSH into the Reverse Proxy using the private IP address. From the Reverse Proxy, test internal DNS resolution and HTTP connectivity to the Web Server. Commands:\nssh azureuser@\u0026lt;BastionHost_PublicIP\u0026gt; curl http://webserver.internal.cloudapp.net:8080 Expected Output:\nThe DNS name webserver.internal.cloudapp.net resolves to the Web Server. The HTTP response from the Web Server shows the index.html page with the message: Hello World! 5. Verify Security Configuration # Confirm that: SSH is accessible only via the Bastion Host. HTTP traffic to the Web Server is routed only through the Reverse Proxy. Direct Internet access to the Web Server is blocked. Summary of Verification Steps # NSG and Subnet: Ensure the NSG is applied correctly to the subnet, restricting access as per rules. ASG Configuration: Verify the ASGs are correctly assigned to the Reverse Proxy and Bastion Host. Internal DNS: Validate that the Reverse Proxy uses the Web Server’s internal DNS name for communication. Cloud-Init Automation: Ensure the Web Server and Reverse Proxy are configured correctly via cloud-config without manual intervention. "},{"id":5,"href":"/docs/4.-exercises/1.-virtual-machine/exercise-2---provisioning-a-vm-with-ssh-keys-and-exploring-linux/","title":"2. Provisioning a VM with SSH Keys and Exploring Linux","section":"1. Virtual Machine","content":" Overview # This exercise introduces secure SSH authentication using Azure Portal\u0026rsquo;s Generate Key Pair feature. You will also connect to the VM using SSH from your local (your laptop) Terminal. While logged in we will explore the Linux filesystem with basic command-line utilities.\nStep 1: Log in to Azure Portal # Open a web browser and navigate to the Azure Portal. Sign in using your Azure account credentials. Step 2: Create a Virtual Machine with SSH Key Pair # Navigate to Virtual Machines and click Create \u0026gt; Azure Virtual machine. Configure the VM: Subscription: Select your subscription. Create a new Resource Group: LabSSHResourceGroup. (You can create a new resource group here if you don´t have one already) Virtual Machine Name: LabSSHVM. Region: Same as the resource group. Zone options: Select Azure-selected zone Image: Select Ubuntu Server 24.04 LTS. Size: Choose Standard_B1s. Authentication Type: Select SSH Public Key. Username: azureuser. Under SSH Public Key Source, select Generate new key pair. Configure inbound ports: Check Allow selected ports and select HTTP (80) and SSH (22). Note the name for your key pair (e.g., LabSSHKey) and click Download private key and create resource. 💡 Information\nThe Generate new key pair option allows you to securely create an SSH key pair. The private key will be downloaded to your computer and should be stored securely. Azure automatically applies the corresponding public key to the VM.\nStep 3: Secure the SSH Private Key (Only Mac And Linux Users) # Locate the downloaded private key file (e.g., LabSSHKey.pem) on your local machine.\nOpen the Terminal and change file permissions (only Mac/Linux Users)\nchmod 400 ~/Downloads/LabSSHKey.pem 💡 Information\nThe chmod 400 command restricts permissions on the private key file, ensuring it is readable only by the file\u0026rsquo;s owner. This is required for secure SSH connections. Failure to set these permissions will result in SSH errors.\nMake sure the key is in the Downloads folder. Otherwise you need to adjust the command above accordingly.\nStep 4: Connect to the VM # In the Azure Portal, navigate to your VM\u0026rsquo;s Overview tab and copy the public IP address of LabSSHVM.\nOpen your terminal:\nWindows: Use Git Bash. Mac/Linux: Use your default terminal. Connect to the VM using SSH:\nssh -i ~/Downloads/LabSSHKey.pem azureuser@\u0026lt;VM_Public_IP\u0026gt; Replace \u0026lt;VM_Public_IP\u0026gt; with the public IP address you copied. On Windows you might need to use the absolute path for the key. You can usually do that by drag-and-drop the key LabSSHKey.pem from the file explorer into the Terminal ✅ Verification Step:\nEnsure you are logged into the VM and see the azureuser@LabSSHVM prompt.\nStep 5: Explore the Linux Filesystem # List the contents of the root directory:\nls / Key directories: /home: User home directories. /etc: Configuration files. /var: Logs and variable data. Check your current working directory:\npwd 💡 Information\nThe Linux filesystem is hierarchical, starting from / (root).\nStep 6: Create and Execute a Bash Script to Install Nginx # Create the Bash Script:\nWhile logged into the VM, create a new script file:\nnano install_nginx.sh Add the following content to the file:\n#!/bin/bash apt update apt install nginx -y Save and exit by pressing CTRL+X, y, Enter.\nMake the Script Executable:\nchmod +x install_nginx.sh Run the Script with Elevated Privileges:\nsudo ./install_nginx.sh Verify the Installation:\nCheck if Nginx is running:\nsystemctl status nginx Ensure the status shows active (running).\nTest Nginx using curl:\ncurl localhost The output should include the default Nginx HTML content, such as Welcome to nginx!.\n💡 Information\nSystemctl and the Init System\nThe systemctl command is used to interact with the system\u0026rsquo;s init system (often systemd on modern Linux distributions). It is responsible for managing services, such as starting, stopping, enabling, or checking the status of services like Nginx.\nstart: Starts the service immediately. enable: Configures the service to start automatically at boot. status: Displays the current status of the service. Step 7: Clean Up Resources (Optional) # In the Azure Portal, go to Resource Groups and locate LabSSHResourceGroup. Click Delete resource group. Exercise Complete! # You have successfully provisioned a VM using Azure\u0026rsquo;s Generate Key Pair feature, connected securely using SSH, and explored the Linux filesystem and basic commands.\n"},{"id":6,"href":"/docs/2.-exercises/1.-presentation-layer/3.-implement-helper-tags-and-model-binding/","title":"3. Helper Tags and Model Binding","section":"1. Presentation Layer","content":" Helper Tags and Model Binding # Goal # Enhance the existing form by introducing ASP.NET Core helper tags, model binding (without annotations), and ViewBag for feedback messages.\nLearning Objectives # By the end of this exercise, you will:\nUse ASP.NET Core Tag Helpers (asp-for, asp-action) Implement model binding without validation attributes Utilize ViewBag to display feedback messages after form submission Step-by-Step Instructions # Step 1: Create a Model for Form Data # Navigate to the Models folder and create a new file named Subscriber.cs. Define a simple class with Name and Email properties. Models/Subscriber.cs\nnamespace CloudSoft.Models; public class Subscriber { public string? Name { get; set; } public string? Email { get; set; } } Information\nThis model will store the form input values and be used for model binding in the controller.\nStep 2: Update the Controller # Open NewsletterController.cs in the Controllers folder. Modify the Subscribe action to accept a Subscriber model and store feedback in ViewBag. Controllers/NewsletterController.cs\nusing CloudSoft.Models; using Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { [HttpGet] public IActionResult Subscribe() { return View(); } [HttpPost] public IActionResult Subscribe(Subscriber subscriber) { // Add subscription logic here // ... // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {subscriber.Name} Email: {subscriber.Email}\u0026#34;); // Send a message to the user ViewBag.Message = $\u0026#34;Thank you for subscribing, {subscriber.Name}!\u0026#34;; // Return the view return View(); } } Information\nThe Subscribe method now accepts a Subscriber model, allowing model binding to populate properties automatically. ViewBag.Message stores feedback that can be displayed in the view. Step 3: Update the View to Use Tag Helpers and Display Feedback # Open Views/Newsletter/Subscribe.cshtml. Modify the form to use Tag Helpers and display the feedback message. Views/Newsletter/Subscribe.cshtml\n@model CloudSoft.Models.Subscriber @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Newsletter Signup\u0026#34;; } \u0026lt;h2\u0026gt;Newsletter Signup\u0026lt;/h2\u0026gt; @if (ViewBag.Message != null) { \u0026lt;p style=\u0026#34;color: green;\u0026#34;\u0026gt;@ViewBag.Message\u0026lt;/p\u0026gt; } \u0026lt;form asp-action=\u0026#34;Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Name\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;label asp-for=\u0026#34;Email\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Email\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; Information\n@model CloudSoft.Models.Subscriber tells the view what model to use. ViewBag.Message is displayed after a successful submission. The asp-action helper automatically sets the form action to Subscribe. The asp-for Tag Helpers bind input fields directly to the Subscriber model. Step 4: Update the NavBar # The layout defines the shared structure of your application.\nOpen the _Layout.cshtml file in the Views/Shared folder. Add a navigation link to the Newsletter Subscription feature: Views/Shared/_Layout.cshtml\n\u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-controller=\u0026#34;Newsletter\u0026#34; asp-action=\u0026#34;Subscribe\u0026#34;\u0026gt;Subscribe\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Fill out the form and submit it.\nEnsure the page reloads and displays a confirmation message.\nShout Out! 🎉 # Great job implementing Tag Helpers and Model Binding! Next, we\u0026rsquo;ll enhance validation to improve user experience. 🚀\n"},{"id":7,"href":"/docs/4.-exercises/1.-virtual-machine/exercise-3---automating-nginx-installation-with-custom-data-scripts/","title":"3. Automating Nginx Installation with Custom Data Scripts","section":"1. Virtual Machine","content":" Overview # This exercise introduces the use of custom data scripts to automate the installation of Nginx during VM provisioning. You will also edit the default Nginx index page to display custom content.\nStep 1: Log in to Azure Portal # Open a web browser and navigate to the Azure Portal. Sign in using your Azure account credentials. Step 2: Create a Virtual Machine with Custom Data # Navigate to Virtual Machines in the Azure Portal and click Create \u0026gt; Virtual machine.\nConfigure the VM:\nSubscription: Select your subscription. Create a new Resource Group: LabCustomDataRG. Virtual Machine Name: LabCustomDataVM. Region: Same as the resource group. Zone options: Select Azure-selected zone Image: Select Ubuntu Server 24.04 LTS. Size: Choose Standard_B1s. Authentication Type: Select SSH Public Key. Username: azureuser. SSH Public Key Source: Use an existing SSH key or generate a new one. Allow selected ports and select HTTP (80) and SSH (22). Under Advanced \u0026gt; Custom Data, paste the content:\n#!/bin/bash apt update apt install nginx -y Click Review + Create, and then Create.\n💡 Information\nThe Custom Data field allows you to execute a script during the initial boot of the VM, automating configurations and software installations.\nThis script:\nUpdates the system\u0026rsquo;s package list (apt update). Installs the Nginx web server (apt install nginx -y). It is important that you 1) don´t use sudo 2) make sure it is non-interactive 3) use a shebang\n✅ Verification Step:\nOpen a browser and go to the \u0026lt;VM_Public_IP\u0026gt;. You should see the \u0026ldquo;Welcome to Nginx!\u0026rdquo; default page. This might take a minute, so be patient and refresh the page.\nStep 3: Edit the Nginx Default Page # Connect to the VM using SSH:\nssh -i \u0026lt;private-key\u0026gt; azureuser@\u0026lt;VM_Public_IP\u0026gt; Replace \u0026lt;private-key\u0026gt; with your private key file. Replace \u0026lt;VM_Public_IP\u0026gt; with the VM\u0026rsquo;s public IP address. Don´t forget to chmod 400 the key if you are on Mac or Linux Navigate to the Nginx root directory:\ncd /var/www/html/ Open index.nginx-debian.html in a text editor:\nsudo nano index.nginx-debian.html Modify the content (e.g., add \u0026ldquo;Hello World\u0026rdquo; to the \u0026lt;h1\u0026gt; tag).\nSave and exit by pressing Ctrl+x, y, and Enter.\n✅ Verification Step:\nRefresh the page in your browser or rerun the curl localhost command to see the updated content.\nStep 4: Clean Up Resources (Optional) # In the Azure Portal, go to Resource Groups and locate LabSSHResourceGroup. Click Delete resource group. Exercise Complete! # You have successfully automated the installation of Nginx using a custom data script and edited the default web page to display custom content.\n"},{"id":8,"href":"/docs/2.-exercises/1.-presentation-layer/4.-client-side-validation-with-data-annotations/","title":"4. Data Annotations and Client-Side Validation","section":"1. Presentation Layer","content":" Data Annotations and Client-Side Validation # Goal # Enhance the existing form by introducing data annotations for client-side validation to improve user experience and enforce input constraints.\nLearning Objectives # By the end of this exercise, you will:\nUse data annotations ([Required], [EmailAddress], [StringLength]) Enable client-side validation using ASP.NET Core built-in validation Improve form feedback with validation messages Step-by-Step Instructions # Step 1: Update the Model with Data Annotations # Open Subscriber.cs in the Models folder. Add validation attributes to enforce required fields and format constraints. Models/Subscriber.cs\nusing System.ComponentModel.DataAnnotations; namespace CloudSoft.Models; public class Subscriber { [Required] [StringLength(20, ErrorMessage = \u0026#34;Name cannot exceed 20 characters\u0026#34;)] public string? Name { get; set; } [Required] [EmailAddress] public string? Email { get; set; } } Information\n[Required] ensures the field must be filled. [StringLength] limits the length of the Name field. [EmailAddress] ensures a valid email format. Step 2: Update the View to Display Validation Messages # Open Views/Newsletter/Subscribe.cshtml. Add validation messages for form fields. Views/Newsletter/Subscribe.cshtml\n@model CloudSoft.Models.Subscriber @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Newsletter Signup\u0026#34;; } \u0026lt;h2\u0026gt;Newsletter Signup\u0026lt;/h2\u0026gt; @if (ViewBag.Message != null) { \u0026lt;p style=\u0026#34;color: green;\u0026#34;\u0026gt;@ViewBag.Message\u0026lt;/p\u0026gt; } \u0026lt;form asp-action=\u0026#34;Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Name\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Name\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Email\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Email\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Email\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; @section Scripts { \u0026lt;partial name=\u0026#34;_ValidationScriptsPartial\u0026#34; /\u0026gt; } Information\nThe asp-validation-for displays validation errors next to fields. _ValidationScriptsPartial enables client-side validation using jQuery. Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Try submitting the form with missing or invalid data.\nEnsure error messages appear and prevent submission.\nFill in valid data and confirm successful submission.\nShout Out! 🎉 # Fantastic job! You\u0026rsquo;ve successfully added data validation and client-side validation 🚀\n"},{"id":9,"href":"/docs/2.-exercises/1.-presentation-layer/5.-server-side-validation/","title":"5. Server-Side Validation and Improved Feedback","section":"1. Presentation Layer","content":" Server-Side Validation and Improved Feedback # Goal # Enhance the form by introducing server-side validation, managing a list of subscribers, and improving feedback handling using TempData and model-level errors.\nLearning Objectives # By the end of this exercise, you will:\nImplement server-side validation for better security. Store subscribers in a list within the controller. Use regular expressions to validate email format. Prevent duplicate email signups. Replace ViewBag with TempData for better feedback persistence. Use ModelState.AddModelError to improve error handling. Step-by-Step Instructions # Step 1: Update the Model with Server-Side Validation # Open Subscriber.cs in the Models folder. Improve client-side email validation using regular expressions. Models/Subscriber.cs\nusing System.ComponentModel.DataAnnotations; namespace CloudSoft.Models; public class Subscriber { [Required] [StringLength(20, ErrorMessage = \u0026#34;Name cannot exceed 20 characters\u0026#34;)] public string? Name { get; set; } [Required] [EmailAddress] [RegularExpression(\u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\u0026#34;, ErrorMessage = \u0026#34;Missing top level domain\u0026#34;)] public string? Email { get; set; } } Information # The RegularExpression attribute enforces stricter email format validation. This prevents malformed or suspicious email input. Step 2: Update the Controller to Store Subscribers and Prevent Duplicates # Open NewsletterController.cs. Modify the Subscribe method to check for duplicate emails and store data in memory. Controllers/NewsletterController.cs\nusing System.Text.RegularExpressions; using CloudSoft.Models; using Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { // Create a \u0026#34;database\u0026#34; of subscribers for demonstration purposes private static List\u0026lt;Subscriber\u0026gt; _subscribers = []; [HttpGet] public IActionResult Subscribe() { return View(); } [HttpPost] public IActionResult Subscribe(Subscriber subscriber) { // Validate the model if (!ModelState.IsValid) { return View(subscriber); } // Check if the email is already subscribed and return a general model level error if (_subscribers.Any(s =\u0026gt; s.Email == subscriber.Email)) { ModelState.AddModelError(\u0026#34;Email\u0026#34;, \u0026#34;The email is already subscribed. Please use a different email.\u0026#34;); return View(subscriber); } // Add the subscriber to the list _subscribers.Add(subscriber); // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {subscriber.Name} Email: {subscriber.Email}\u0026#34;); // Send a message to the user TempData[\u0026#34;SuccessMessage\u0026#34;] = $\u0026#34;Thank you for subscribing, {subscriber.Name}! You will receive our newsletter at {subscriber.Email}\u0026#34;; // Return the view (using the POST-REDIRECT-GET pattern) return RedirectToAction(nameof(Subscribe)); // use nameof() to find the action by name during compile time } } Information\n_subscribers list stores all registered users in memory. Checks if the email already exists before allowing submission. Uses ModelState.AddModelError for field-specific error messages. TempData replaces ViewBag for better feedback persistence across redirects. Step 3: Update the View to Display Errors and TempData Feedback # Open Views/Newsletter/Subscribe.cshtml. Modify the form to display server-side validation errors and TempData messages. Views/Newsletter/Subscribe.cshtml\n@model CloudSoft.Models.Subscriber @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Newsletter Signup\u0026#34;; } \u0026lt;h2\u0026gt;Newsletter Signup\u0026lt;/h2\u0026gt; \u0026lt;!-- Display validation summary for model-level errors --\u0026gt; @if (!ViewData.ModelState.IsValid) { \u0026lt;div class=\u0026#34;alert alert-danger alert-dismissible fade show\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; @Html.ValidationSummary(false, null, new { @class = \u0026#34;text-danger\u0026#34; }) \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn-close\u0026#34; data-bs-dismiss=\u0026#34;alert\u0026#34; aria-label=\u0026#34;Close\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-times\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;!-- Display message from the TempData sent by the controller --\u0026gt; @if (TempData[\u0026#34;SuccessMessage\u0026#34;] != null) { \u0026lt;div class=\u0026#34;alert alert-success alert-dismissible fade show\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; @TempData[\u0026#34;SuccessMessage\u0026#34;] \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn-close\u0026#34; data-bs-dismiss=\u0026#34;alert\u0026#34; aria-label=\u0026#34;Close\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-times\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;form asp-action=\u0026#34;Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Name\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Name\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Email\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Email\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Email\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-3\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; @section Scripts { \u0026lt;partial name=\u0026#34;_ValidationScriptsPartial\u0026#34; /\u0026gt; } Information # TempData message is displayed when redirecting after a successful submission. asp-validation-for displays field-specific validation errors. _ValidationScriptsPartial enables client-side validation. Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Try submitting invalid or empty input and confirm error messages.\nTry registering with the same email twice and confirm the duplicate warning.\nSubmit valid data and check if feedback persists correctly using TempData.\nShout Out! 🎉 # Awesome work! You\u0026rsquo;ve implemented server-side validation, handled duplicate entries, and improved feedback management. 🚀\n"},{"id":10,"href":"/docs/2.-exercises/1.-presentation-layer/6.-display-a-list-of-subscribers/","title":"6. Displaying a List of Subscribers","section":"1. Presentation Layer","content":" Displaying a List of Subscribers # Goal # Enhance the application by adding a new view to list all subscribers and updating the navigation bar to include a button linking to the new page.\nLearning Objectives # By the end of this exercise, you will:\nCreate a new view to display a list of subscribers. Modify the controller to pass subscriber data to the view. Update the navigation bar to provide access to the new page. Step-by-Step Instructions # Step 1: Update the Controller to Provide Subscriber Data # Open NewsletterController.cs. Add a new action method to return a list of subscribers to the view. Controllers/NewsletterController.cs\n... [HttpGet] public IActionResult Subscribers() { return View(_subscribers); } ... Information\nSubscribers() action returns the list of subscribers to the view. The list is retrieved from the in-memory static list. Step 2: Create the Subscriber List View # Navigate to the Views/Newsletter/ folder. Create a new file named Subscribers.cshtml. Add the following code to display subscribers in a table. Views/Newsletter/Subscribers.cshtml\n@model List\u0026lt;CloudSoft.Models.Subscriber\u0026gt; @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Subscriber List\u0026#34;; } \u0026lt;h2\u0026gt;Subscriber List\u0026lt;/h2\u0026gt; @if (Model.Count == 0) { \u0026lt;p\u0026gt;No subscribers yet.\u0026lt;/p\u0026gt; } else { \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Email\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var subscriber in Model) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;@subscriber.Name\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@subscriber.Email\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; } Information\nDisplays all subscribers in a table. If no subscribers exist, it shows a fallback message. Step 3: Add a Navigation Button to the Navbar # Open Views/Shared/_Layout.cshtml. Add a new navigation link to the Subscriber List page. Views/Shared/_Layout.cshtml\n... \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-controller=\u0026#34;Newsletter\u0026#34; asp-action=\u0026#34;Subscribers\u0026#34;\u0026gt;Subscribers\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; ... Information\nAdds a navigation button to access the Subscriber List page. Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Subscribe with multiple names and emails.\nClick Subscribers in the navbar to view the subscriber list.\nEnsure all submitted data appears correctly in the table.\nShout Out! 🎉 # Great job! You\u0026rsquo;ve successfully added a subscriber list page and a navigation button to improve user experience! 🚀\n"}]