[{"id":0,"href":"/docs/2.-exercises/1.-presentation-layer/1.-hello-world/","title":"1. Hello World","section":"1. Presentation Layer","content":" Hello World # Create the app\ndotnet new mvc dotnet new gitignore Run the app\ndotnet run Prepare the app for git\ndotnet new gitignore git init git add . git commit -m \u0026#34;Create MVC webapp\u0026#34; Use VS Code to publish the repository to Github. After that you can push commits with:\ngit push "},{"id":1,"href":"/docs/4.-exercises/2.-network/exercise-1---creating-a-virtual-network/","title":"1. Creating a Virtual Network (vNet)","section":"2. Network","content":" Overview # The objective of this exercise is to create a Virtual Network (vNet) with a default subnet using the Azure Portal, laying the foundation for a secure network architecture. You will also provision three servers having the roles Web Server, Reverse Proxy and Bastion Host respectively. Finally, firewall rules will be created to secure the network using Azure Network Security Groups (NSG)\nStep 1: Log in to Azure Portal # Open https://portal.azure.com. Sign in with your Azure account credentials. Step 2: Create a Virtual Network # In the Azure Portal, use the search bar at the top to search for \u0026ldquo;Virtual Networks\u0026rdquo;. Select Virtual Networks from the search results or from the left menu Click the + Create button at the top of the Virtual Networks page. On the Basics tab, fill in the following information: Subscription: Select your subscription. Resource Group: Choose an existing resource group or create a new one (e.g., DemoRG). Name: Enter DemoVNet. Region: Choose a region close to your location (e.g., North Europe). Click Review + Create and then click Create to deploy the Virtual Network. 💡 Information\nA Virtual Network (VNet) is the foundation of a cloud-based network. Subnets allow logical segmentation within the VNet for better security and resource management. The address space 10.0.0.0/16 allows over 65,000 addresses, and subnets divide this range into smaller, manageable blocks (in this case the default subnet 10.0.0.0/24) ✅ Verification Step:\nAfter deployment, return to Virtual Networks in the Azure Portal. Select the DemoVNet from the list of Virtual Networks. Confirm that the following settings are present: Address Space: 10.0.0.0/16. Subnets: default with address range 10.0.0.0/24. Step 2: Provision an Ubuntu VM in the VNet/Subnet (Web Server) # In the Azure Portal, go to \u0026ldquo;Virtual Machines\u0026rdquo; Create a New Virtual Machine Click + Create at the top of the Virtual Machines page.\nSubscription: Select the subscription used in Step 1.\nResource Group: Select the same resource group as before.\nVirtual Machine Name: Enter a name, e.g., WebServer.\nRegion: Use the same region as the VNet.\nImage: Choose Ubuntu Server 24.04 LTS.\nSize: Select a small size, e.g., Standard_B1s.\nAdministrator Account:\nAuthentication Type: Select SSH Public Key. Username: Enter azureuser. SSH Public Key: Generate new key pair. Go to the network tab\nUnder Virtual Network, select the VNet created in Step 1. For Subnet, choose the default subnet created in Step 1. Public IP: Ensure a public IP address is assigned. NIC Network Security Group: Select Basic and allow SSH (port 22). Go to the advanced tab\nUse custom data to install nginx #!/bin/bash apt update apt install nginx -y Click Review + create and then Create.\nStep 3: Configure the Web Server # Login to the WebServer and change the default Nginx page to \u0026ldquo;Welcome World\u0026rdquo;\nRun the following commands to change the port nginx listens to (just for this exercise to show that web servers and app servers can potentially listen to many different ports. 8080 is a very common port to use)\nsudo sed -i \u0026#39;s/listen 80 default_server;/listen 8080 default_server;/\u0026#39; /etc/nginx/sites-available/default sudo sed -i \u0026#39;/listen \\[::\\]:80 default_server;/d\u0026#39; /etc/nginx/sites-available/default sudo nginx -s reload sudo sed -i \u0026#39;s/Welcome to nginx/Hello World/g\u0026#39; /var/www/html/index.nginx-debian.html ✅ Verification Step:\nRun curl and verify output from default page curl localhost:8080 Step 4: Provision another Ubuntu VM in the VNet/Subnet (Reverse Proxy) # Create another identical VM (including installing Nginx) Name it ReverseProxy Step 5: Configure the Reverse Proxy # Login to the ReverseProxy and run\ncurl \u0026lt;PrivateIP_WebServer\u0026gt;:8080 ✅ Verification Step:\nVerify output from default page of the Web Server\n💡 Information\nThere is no firewall between servers in the same network You can also use the private IPs within the same vNet In order to give the Reverse Proxy its role as \u0026ldquo;Reverse Proxy\u0026rdquo; we need to edit the file /etc/nginx/sites-available/default. Replace the content with this (change the Private IP and Port):\nsudo nano /etc/nginx/sites-available/default server { listen 80 default_server; location / { proxy_pass http://\u0026lt;PrivateIP\u0026gt;:\u0026lt;Port\u0026gt;/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } sudo nginx -t sudo nginx -s reload curl localhost ✅ Verification Step:\nVerify output from default page of the Web Server\n💡 Information\nNginx is a very versatile software that beside being used for web servers it is also very often used for reverse proxies.\nStep 6: Provision another Ubuntu VM in the VNet/Subnet (Bastion Host) # Create another identical VM (but don´t install Nginx) Name it BastionHost Step 7: Use the Bastion Host to SSH in to the other servers # Login to the Bastion Host.\nTry to login to the other two servers from here.\n💡 Information\nEach server has its own ssh key. We don´t want to store the keys on the Bastion Host, instead we use an ssh agent to bring the keys to the other servers in memory to the Bastion Host.\nExit the terminal, so that you are back on your laptop\nStart the SSH Agent, on your laptop, and give it the keys:\neval $(ssh-agent) ssh-add ~/Downloads/WebServer_key.pem ssh-add ~/Downloads/ReverseProxy_key.pem ssh-add ~/Downloads/BastionHost_key.pem ssh-add -l SSH Jump via BastionHost using the Agent (-A):\nssh -A azureuser@\u0026lt;BastionHost_IP\u0026gt; Inside the BastionHost, try to SSH into WebServer using its private IP:\nssh -A azureuser@\u0026lt;WebServer_InternalIP\u0026gt; ✅ Verification Step:\nVerify that you could SSH into the Web Server\nStep 8: Secure the solution with NSG (Network Security Groups) # Currently there is one NSG for each NIC of each server. You will find the firewall rules in each NSG under the menu Networking -\u0026gt; Network settings for each VM.\nModify the NSG of the Web Server\nNavigate to the WebServer VM Select the menu Networking -\u0026gt; Network settings Follow the link WebServer-nsg Delete the row with the SSH rule. ✅ Verification Step:\nVerify that you cannot SSH into the Web Server from the Internet Verify that you can SSH into the Web Server from the BastionHost Verify that you cannot browse (HTTP) into the Web Server from the Internet Verify that you can browse (HTTP) into the Web Server from the ReverseProxy Modify the NSG of the Reverse Proxy\nNavigate to the ReverseProxy VM Select the menu Networking -\u0026gt; Network settings Follow the link ReverseProxy-nsg Delete the row with the SSH rule. Select the menu Settings -\u0026gt; Inbound security rules Click + Add In Service, choose HTTP Click Add ✅ Verification Step:\nVerify that you cannot SSH into the Reverse Proxy from the Internet Verify that you can SSH into the Reverse Proxy from the BastionHost Verify that you can browse (HTTP) into the Reverse Proxy from the Internet Verify that you get the page served by the Web Server (Hello World) Conclusion # By completing this exercise, you achieved the following learning outcomes:\nVNet Creation: Established a Virtual Network with a subnet to provide a secure foundation for cloud infrastructure. VM Provisioning: Deployed and configured VMs with specific roles (Web Server, Reverse Proxy, Bastion Host) to simulate a functional network. Nginx Configuration: Explored the use of Nginx as a web server and reverse proxy. Secure Networking: Applied Azure NSGs to enforce access control and secure the environment. SSH Agent Forwarding: Practiced secure internal server management without exposing sensitive credentials. "},{"id":2,"href":"/docs/2.-exercises/1.-presentation-layer/2.-create-a-form-using-basic-html/","title":"2. Create A Form With Basic HTML","section":"1. Presentation Layer","content":" Create A Form With Basic HTML # Goal # Create a basic HTML form that collects name and email and submits it via POST. This step introduces fundamental form handling in an ASP.NET Core MVC web application without using advanced features like model binding or validation.\nLearning Objectives # By the end of this exercise, you will:\nUnderstand how to create an HTML form with basic input fields. Learn how to submit form data using an HTTP POST request. Implement a controller to handle form display and submission. Display submitted data in the application console. Step-by-Step Instructions # Step 1: Create a Controller # Navigate to the Controllers folder and create a new file named NewsletterController.cs. Add action methods to display the form and handle form submission. File: Controllers/NewsletterController.cs\nusing Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { // GET: /Newsletter/Subscribe public IActionResult Subscribe() { return View(); } // POST: /Newsletter/Subscribe [HttpPost] public IActionResult Subscribe(string name, string email) { // Add subscription logic here // ... // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {name} Email: {email}\u0026#34;); // Send a message to the user return Content($\u0026#34;Thank you {name} for subscribing to our newsletter!\u0026#34;); } } 💡 Information\nThe ”Get” Subscribe() method renders the page with the form. The ”Post\u0026quot; Subscribe() method handles the form submission and returns a simple message. Step 2: Create the Form View # Navigate to the Views/Newsletter/ folder. Create a new file named Subscribe.cshtml. Add the following HTML code for the form: File: Views/Newsletter/Subscribe.cshtml\n@{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Sign up for our newsletter\u0026#34;; } \u0026lt;h2\u0026gt;Signup up for our newsletter\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/Newsletter/Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 💡 Information\nThis form submits data to /Newsletter/Signup via HTTP POST. When the form is submitted, the following data is sent back to the server via POST: name: The user\u0026rsquo;s entered name. email: The user\u0026rsquo;s entered email address. It is the name attribute (name=\u0026ldquo;email\u0026rdquo;) in the form input field that is sent back to the server. The id attribute is used within the browser page for linking labels to input fields. Final Tests # Step 1: Run the Application # Start the application:\ndotnet run Then open the browser and navigate to:\nhttp://localhost:\u0026lt;PORT\u0026gt;/Newsletter/Subscribe Change the port to what you have\n✅ Expected Result\nYou should see your form page Step 2: Fill Out and Submit the Form # Enter a name and an incorrect email (without @)\nClick Sign Up.\nEnter a name and a correct email\nClick Sign Up\n✅ Expected Result\nThe incorrect email should show an information message\nUpon correct submission, the browser should display:\nThank you [entered name] for subscribing to our newsletter! In the application console, you should see:\nNew subscription - Name: [Your Name], Email: [Your Email] You have a form! 🚀 # "},{"id":3,"href":"/docs/4.-exercises/2.-network/exercise-2---creating-a-virtual-network-with-enhanced-security/","title":"2. Creating a Virtual Network with Enhanced Security","section":"2. Network","content":" Overview # The objective of this exercise is to create a Virtual Network (vNet) with a subnet secured by a Network Security Group (NSG) attached to the subnet itself. You will also provision three servers with specific roles: Web Server, Reverse Proxy, and Bastion Host. Application Security Groups (ASGs) will be configured for the Reverse Proxy and Bastion Host, and all server configurations will be automated using cloud-init.\nStep 1: Log in to Azure Portal # Open https://portal.azure.com. Sign in with your Azure account credentials. Step 2: Create a Virtual Network # In the Azure Portal, use the search bar at the top to search for \u0026ldquo;Virtual Networks\u0026rdquo;. Select Virtual Networks from the search results or from the left menu Click the + Create button at the top of the Virtual Networks page. On the Basics tab, fill in the following information: Subscription: Select your subscription. Resource Group: Choose an existing resource group or create a new one (e.g., DemoRG). Name: Enter DemoVNet. Region: Choose a region close to your location (e.g., North Europe). Click Review + Create and then click Create to deploy the Virtual Network. Step 3: Create Application Security Groups # In the Azure Portal, search for Application Security Groups.\nCreate two ASGs:\nReverse Proxy:\nName: ReverseProxyASG Resource Group: DemoRG Bastion Host:\nName: BastionHostASG Resource Group: DemoRG Step 4: Create a Network Security Group and Rules # In the Azure Portal, search for Network Security Groups.\nClick + Create and provide the following information:\nName: DemoNSG. Resource Group: Select DemoRG. Region: Choose the same region as the VNet. Got to resource and add inbound security rules:\nGo to Settings -\u0026gt; Inbound security rules SSH:\nSource: Service Tag Source service tag: Internet Destination: Application security group Destination application security group: BastionHostASG Service: SSH Click Add HTTP:\nSource: Service Tag Source service tag: Internet Destination: Application security group Destination application security group: ReverseProxyASG Service: HTTP Click Add Attach the NSG to the default subnet in the VNet.\nGo to Settings -\u0026gt; Subnets Click + Associate and select Virtual network: DemoVNet Subnet: default Step 5: Provision VMs and Configure with Cloud-Init # Create three VMs using the following specifications: VM Names: WebServer, ReverseProxy, BastionHost.\nImage: Ubuntu Server 24.04 LTS.\nSize: Standard_B1s.\nSubnet: Use default.\nPublic IP: Attach only to the Bastion Host and the Reverse Proxy.\nNSG: Leave None for all NICs.\nASG: Attach ReverseProxyASG to the Reverse Proxy and BastionHostASG to the Bastion Host.\nWebServer (cloud-config):\n#cloud-config packages: - nginx write_files: - path: /var/www/html/index.html content: | \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello World!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; - path: /etc/nginx/sites-available/default content: | server { listen 8080 default_server; server_name _; root /var/www/html; index index.html; } runcmd: - systemctl restart nginx ReverseProxy (cloud-config):\n#cloud-config packages: - nginx write_files: - path: /etc/nginx/sites-available/default content: | server { listen 80; location / { proxy_pass http://webserver.internal.cloudapp.net:8080/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } runcmd: - systemctl restart nginx Test and Verify # This chapter ensures the Virtual Network (VNet), Network Security Group (NSG), and Virtual Machines (VMs) are configured correctly and functioning as intended. Follow these steps to verify each aspect of the setup:\n1. Verify NSG Rules # Navigate to the DemoNSG in the Azure Portal. Check the inbound security rules: SSH is allowed only for the BastionHostASG. HTTP traffic is allowed only for the ReverseProxyASG. Confirm that the NSG is associated with the default subnet in the VNet. ✅ Verification Step:\nAttempt SSH access from the Internet to the Web Server or Reverse Proxy. This should fail. Attempt HTTP access to the Web Server directly. This should fail. Attempt HTTP access to the Reverse Proxy. This should succeed. 2. Check Application Security Groups # Ensure the Application Security Groups (ASGs) are correctly associated: ReverseProxyASG is assigned to the Reverse Proxy VM. BastionHostASG is assigned to the Bastion Host VM. ✅ Verification Step:\nNavigate to the Networking section of the Reverse Proxy and Bastion Host VMs. Confirm the ASGs are listed under Application Security Groups. 3. Test HTTP Access to Reverse Proxy # Open a browser or use a tool like curl to access the Reverse Proxy\u0026rsquo;s public IP on port 80. Verify that the Reverse Proxy forwards traffic to the Web Server using its internal DNS name. Command:\ncurl http://\u0026lt;ReverseProxy_PublicIP\u0026gt; Expected Output:\nThe HTTP response displays the content of the Web Server\u0026rsquo;s index.html page with the message: Hello World! 4. Test Internal Communication # Use the Bastion Host to SSH into the Reverse Proxy using the private IP address. From the Reverse Proxy, test internal DNS resolution and HTTP connectivity to the Web Server. Commands:\nssh azureuser@\u0026lt;BastionHost_PublicIP\u0026gt; curl http://webserver.internal.cloudapp.net:8080 Expected Output:\nThe DNS name webserver.internal.cloudapp.net resolves to the Web Server. The HTTP response from the Web Server shows the index.html page with the message: Hello World! 5. Verify Security Configuration # Confirm that: SSH is accessible only via the Bastion Host. HTTP traffic to the Web Server is routed only through the Reverse Proxy. Direct Internet access to the Web Server is blocked. Summary of Verification Steps # NSG and Subnet: Ensure the NSG is applied correctly to the subnet, restricting access as per rules. ASG Configuration: Verify the ASGs are correctly assigned to the Reverse Proxy and Bastion Host. Internal DNS: Validate that the Reverse Proxy uses the Web Server’s internal DNS name for communication. Cloud-Init Automation: Ensure the Web Server and Reverse Proxy are configured correctly via cloud-config without manual intervention. "},{"id":4,"href":"/docs/2.-exercises/1.-presentation-layer/3.-implement-helper-tags-and-model-binding/","title":"3. Helper Tags and Model Binding","section":"1. Presentation Layer","content":" Helper Tags and Model Binding # Goal # Enhance the existing form by introducing ASP.NET Core helper tags, model binding (without annotations), and ViewBag for feedback messages.\nLearning Objectives # By the end of this exercise, you will:\nUse ASP.NET Core Tag Helpers (asp-for, asp-action) Implement model binding without validation attributes Utilize ViewBag to display feedback messages after form submission Step-by-Step Instructions # Step 1: Create a Model for Form Data # Navigate to the Models folder and create a new file named Subscriber.cs. Define a simple class with Name and Email properties. Models/Subscriber.cs\nnamespace CloudSoft.Models; public class Subscriber { public string? Name { get; set; } public string? Email { get; set; } } Information\nThis model will store the form input values and be used for model binding in the controller.\nStep 2: Update the Controller # Open NewsletterController.cs in the Controllers folder. Modify the Subscribe action to accept a Subscriber model and store feedback in ViewBag. Controllers/NewsletterController.cs\nusing CloudSoft.Models; using Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { [HttpGet] public IActionResult Subscribe() { return View(); } [HttpPost] public IActionResult Subscribe(Subscriber subscriber) { // Add subscription logic here // ... // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {subscriber.Name} Email: {subscriber.Email}\u0026#34;); // Send a message to the user ViewBag.Message = $\u0026#34;Thank you for subscribing, {subscriber.Name}!\u0026#34;; // Return the view return View(); } } Information\nThe Subscribe method now accepts a Subscriber model, allowing model binding to populate properties automatically. ViewBag.Message stores feedback that can be displayed in the view. Step 3: Update the View to Use Tag Helpers and Display Feedback # Open Views/Newsletter/Subscribe.cshtml. Modify the form to use Tag Helpers and display the feedback message. Views/Newsletter/Subscribe.cshtml\n@model CloudSoft.Models.Subscriber @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Newsletter Signup\u0026#34;; } \u0026lt;h2\u0026gt;Newsletter Signup\u0026lt;/h2\u0026gt; @if (ViewBag.Message != null) { \u0026lt;p style=\u0026#34;color: green;\u0026#34;\u0026gt;@ViewBag.Message\u0026lt;/p\u0026gt; } \u0026lt;form asp-action=\u0026#34;Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Name\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;label asp-for=\u0026#34;Email\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Email\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; Information\n@model CloudSoft.Models.Subscriber tells the view what model to use. ViewBag.Message is displayed after a successful submission. The asp-action helper automatically sets the form action to Subscribe. The asp-for Tag Helpers bind input fields directly to the Subscriber model. Step 4: Update the NavBar # The layout defines the shared structure of your application.\nOpen the _Layout.cshtml file in the Views/Shared folder. Add a navigation link to the Newsletter Subscription feature: Views/Shared/_Layout.cshtml\n\u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-controller=\u0026#34;Newsletter\u0026#34; asp-action=\u0026#34;Subscribe\u0026#34;\u0026gt;Subscribe\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Fill out the form and submit it.\nEnsure the page reloads and displays a confirmation message.\nShout Out! 🎉 # Great job implementing Tag Helpers and Model Binding! Next, we\u0026rsquo;ll enhance validation to improve user experience. 🚀\n"},{"id":5,"href":"/docs/4.-exercises/2.-network/exercise-3---creating-a-virtual-network-with-enhanced-security-using-azure-cli/","title":"3. Creating a Virtual Network with Enhanced Security using Azure CLI","section":"2. Network","content":" Overview # This exercise will guide you through provisioning a complete solution on Azure using only Azure CLI. The solution comprises three servers: a web server, a reverse proxy, and a bastion host. These components are connected via a virtual network and secured with a Network Security Group (NSG) and Application Security Groups (ASGs).\nBy the end of this exercise, you will have a working environment with secure, isolated network communication between components.\nObjectives # Create a resource group and a virtual network to connect the servers. Set up a Network Security Group (NSG) for subnet-level security. Configure Application Security Groups (ASGs) for more granular control. Provision three virtual machines for the web server, reverse proxy, and bastion host. Test the configuration by accessing the reverse proxy through the bastion host. Prerequisites # Azure CLI installed on your machine. If not, install it from here. An active Azure subscription. Step 1: Create a Resource Group # A resource group is a container that holds all the related resources.\nRun the following command to set up the resource group:\naz group create --name DemoRG --location northeurope Explanation:\naz group create: Creates a new resource group. --name DemoRG: Names the resource group DemoRG. --location northeurope: Sets the location to North Europe. Step 2: Create a Virtual Network # The virtual network (VNet) connects the components.\nRun the following command to set up the VNet:\naz network vnet create \\ --resource-group DemoRG \\ --name DemoVNet \\ --address-prefix 10.0.0.0/16 \\ --subnet-name default \\ --subnet-prefix 10.0.0.0/24 Explanation:\naz network vnet create: Creates a virtual network. --resource-group DemoRG: Specifies the resource group. --name DemoVNet: Names the VNet DemoVNet. --address-prefix 10.0.0.0/16: Sets the address space for the VNet. --subnet-name default: Names the subnet default. --subnet-prefix 10.0.0.0/24: Sets the address range for the subnet. Step 3: Configure Network Security # Set Up Application Security Groups (ASGs) # ASGs allow grouping of virtual machines for applying NSG rules more effectively.\naz network asg create \\ --resource-group DemoRG \\ --name ReverseProxyASG az network asg create \\ --resource-group DemoRG \\ --name BastionHostASG Explanation:\naz network asg create: Creates an Application Security Group. --name ReverseProxyASG: Names the ASG ReverseProxyASG. Create the Network Security Group (NSG) # The NSG controls inbound and outbound traffic to the subnet.\naz network nsg create \\ --resource-group DemoRG \\ --name DemoNSG Explanation:\naz network nsg create: Creates a Network Security Group. --name DemoNSG: Names the NSG DemoNSG. --location northeurope: Ensures the NSG is in the same region as the VNet. Apply NSG Rules # a. Allow SSH Access to Bastion Host ASG # Command:\naz network nsg rule create \\ --resource-group DemoRG \\ --nsg-name DemoNSG \\ --name AllowSSH \\ --priority 1000 \\ --access Allow \\ --protocol Tcp \\ --direction Inbound \\ --source-address-prefixes Internet \\ --source-port-ranges \u0026#34;*\u0026#34; \\ --destination-asg BastionHostASG \\ --destination-port-ranges 22 Explanation:\naz network nsg rule create: Adds a rule to the NSG. --nsg-name DemoNSG: Targets the NSG DemoNSG. --name AllowSSH: Names the rule AllowSSH. --priority 1000: Sets the priority (lower number means higher priority). --access Allow: Allows traffic. --protocol Tcp: Applies to TCP protocol. --direction Inbound: Applies to incoming traffic. --source-address-prefixes Internet: Source is any Internet address. --destination-asg BastionHostASG: Targets the BastionHostASG. --destination-port-ranges 22: Applies to port 22 (SSH). b. Allow HTTP Access to Reverse Proxy ASG # Command:\naz network nsg rule create \\ --resource-group DemoRG \\ --nsg-name DemoNSG \\ --name AllowHTTP \\ --priority 2000 \\ --access Allow \\ --protocol Tcp \\ --direction Inbound \\ --source-address-prefixes Internet \\ --source-port-ranges \u0026#34;*\u0026#34; \\ --destination-asg ReverseProxyASG \\ --destination-port-ranges 80 Explanation:\n--name AllowHTTP: Names the rule AllowHTTP. --priority 2000: Sets a lower priority than SSH rule. --destination-asg ReverseProxyASG: Targets the ReverseProxyASG. --destination-port-ranges 80: Applies to port 80 (HTTP). Associate the NSG with the Subnet # Attach the NSG to the VNet\u0026rsquo;s subnet.\naz network vnet subnet update \\ --resource-group DemoRG \\ --vnet-name DemoVNet \\ --name default \\ --network-security-group DemoNSG Step 4: Provision the Virtual Machines # Deploy three VMs: the web server, reverse proxy, and bastion host. Use the configuration files for the web server and reverse proxy.\nProvision the Web Server # Create Configuration File # Create the Web Server Configuration File: Save the following content as web_server_config.yaml:\n#cloud-config packages: - nginx write_files: - path: /var/www/html/index.html content: | \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello World!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; - path: /etc/nginx/sites-available/default content: | server { listen 8080 default_server; server_name _; root /var/www/html; index index.html; } runcmd: - systemctl restart nginx Explanation:\nInstalls Nginx. Creates a custom index.html. Configures Nginx to listen on port 8080. Restarts Nginx service. Ensure the file is accessible to the CLI during VM creation.\nProvision the Web Server # Now, use the configuration file to deploy the web server:\naz vm create \\ --resource-group DemoRG \\ --name WebServer \\ --image Ubuntu2204 \\ --size Standard_B1s \\ --admin-username azureuser \\ --vnet-name DemoVNet \\ --subnet default \\ --nsg \u0026#34;\u0026#34; \\ --public-ip-address \u0026#34;\u0026#34; \\ --generate-ssh-keys \\ --custom-data @web_server_config.yaml Explanation:\naz vm create: Creates a virtual machine. --name WebServer: Names the VM WebServer. --image Ubuntu2204: Uses Ubuntu Server 22.04 LTS image. --size Standard_B1s: Sets the VM size. --admin-username azureuser: Sets the admin username. --vnet-name DemoVNet: Places VM in DemoVNet. --subnet default: Uses the default subnet. --nsg \u0026quot;\u0026quot;: No NSG at NIC level. --public-ip-address \u0026quot;\u0026quot;: No public IP assigned. --generate-ssh-keys: Generates SSH keys if not present. --custom-data web_server_config.yaml: Uses cloud-init file to configure the VM. Provision the Reverse Proxy # Create Configuration File # Create the Reverse Proxy Configuration File: Save the following content as reverse_proxy_config.yaml:\n#cloud-config packages: - nginx write_files: - path: /etc/nginx/sites-available/default content: | server { listen 80; location / { proxy_pass http://webserver.internal.cloudapp.net:8080/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } runcmd: - systemctl restart nginx Explanation:\nInstalls Nginx. Configures Nginx as a reverse proxy to the Web Server. Restarts Nginx service. Ensure the file is accessible to the CLI during VM creation.\nProvision the Reverse Proxy # Now, use the configuration file to deploy the Reverse Proxy :\naz vm create \\ --resource-group DemoRG \\ --name ReverseProxy \\ --image Ubuntu2204 \\ --size Standard_B1s \\ --admin-username azureuser \\ --vnet-name DemoVNet \\ --subnet default \\ --nsg \u0026#34;\u0026#34; \\ --generate-ssh-keys \\ --custom-data @reverse_proxy_config.yaml Explanation:\n--name ReverseProxy: Names the VM ReverseProxy. --generate-ssh-keys: Reuses existing SSH keys. --custom-data reverse_proxy_config.yaml: Uses cloud-init file. Provision the Bastion Host # Provision the Bastion Host # Now, use the configuration file to deploy the Bastion Host :\naz vm create \\ --resource-group DemoRG \\ --name BastionHost \\ --image Ubuntu2204 \\ --size Standard_B1s \\ --admin-username azureuser \\ --vnet-name DemoVNet \\ --subnet default \\ --nsg \u0026#34;\u0026#34; \\ --generate-ssh-keys Explanation:\n--name BastionHost: Names the VM BastionHost. No --custom-data: Standard VM without cloud-init. Public IP Address: Assigned by default for SSH access. Step 5: Attach ASGs to VM NICs # To ensure proper traffic management and rule enforcement, Application Security Groups (ASGs) must be attached to the Network Interface Cards (NICs) of the virtual machines. This step will be divided into two parts: attaching the ASG to the Reverse Proxy and then to the Bastion Host.\nAttach ASG to the Reverse Proxy NIC # Retrieve the NIC ID for the Reverse Proxy virtual machine:\nREVERSE_PROXY_NIC_ID=$(az vm show --resource-group DemoRG --name ReverseProxy --query \u0026#39;networkProfile.networkInterfaces[0].id\u0026#39; --output tsv) Extract the NIC Name from the NIC ID:\nREVERSE_PROXY_NIC_NAME=$(basename $REVERSE_PROXY_NIC_ID) Get the IP Configuration Name for the Reverse Proxy NIC:\nREVERSE_PROXY_NIC_IP_CONFIG=$(az network nic show --resource-group DemoRG --name $REVERSE_PROXY_NIC_NAME --query \u0026#39;ipConfigurations[0].name\u0026#39; --output tsv) Attach the Reverse Proxy ASG to the NIC:\naz network nic ip-config update \\ --resource-group DemoRG \\ --nic-name $REVERSE_PROXY_NIC_NAME \\ --name $REVERSE_PROXY_NIC_IP_CONFIG \\ --application-security-groups ReverseProxyASG Attach ASG to the Bastion Host NIC # Retrieve the NIC ID for the Bastion Host virtual machine:\nBASTION_HOST_NIC_ID=$(az vm show --resource-group DemoRG --name BastionHost --query \u0026#39;networkProfile.networkInterfaces[0].id\u0026#39; --output tsv) Extract the NIC Name from the NIC ID:\nBASTION_HOST_NIC_NAME=$(basename $BASTION_HOST_NIC_ID) Get the IP Configuration Name for the Bastion Host NIC:\nBASTION_HOST_NIC_IP_CONFIG=$(az network nic show --resource-group DemoRG --name $BASTION_HOST_NIC_NAME --query \u0026#39;ipConfigurations[0].name\u0026#39; --output tsv) Attach the Bastion Host ASG to the NIC:\naz network nic ip-config update \\ --resource-group DemoRG \\ --nic-name $BASTION_HOST_NIC_NAME \\ --name $BASTION_HOST_NIC_IP_CONFIG \\ --application-security-groups BastionHostASG Test and Verify # Verify NSG Rules # Ensure that:\nSSH is allowed only to the Bastion Host. HTTP is allowed only to the Reverse Proxy. Verify ASG Assignments # Check that:\nReverseProxyASG is attached to the Reverse Proxy NIC. BastionHostASG is attached to the Bastion Host NIC. Test HTTP Access # Access the Reverse Proxy\u0026rsquo;s public IP on port 80. You should see the \u0026ldquo;Hello World!\u0026rdquo; page served by the Web Server. Test Internal Communication # From the Bastion Host, SSH into the Reverse Proxy using its private IP. From the Reverse Proxy, ensure it can reach the Web Server via its internal DNS name. Summary # In this exercise, you:\nCreated a resource group and a virtual network with a subnet. Configured Application Security Groups and a Network Security Group with specific rules. Provisioned three VMs with roles of Web Server, Reverse Proxy, and Bastion Host. Automated server configurations using cloud-init. Verified that the network security settings work as intended. Cleanup Resources # Once you\u0026rsquo;ve validated the setup, delete the resources to avoid incurring costs:\naz group delete --name DemoRG --yes --no-wait TL;DR # web_server_config.yaml\n#cloud-config packages: - nginx write_files: - path: /var/www/html/index.html content: | \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello World!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; - path: /etc/nginx/sites-available/default content: | server { listen 8080 default_server; server_name _; root /var/www/html; index index.html; } runcmd: - systemctl restart nginx reverse_proxy_config.yaml\n#cloud-config packages: - nginx write_files: - path: /etc/nginx/sites-available/default content: | server { listen 80; location / { proxy_pass http://webserver.internal.cloudapp.net:8080/; proxy_set_header Host \\$host; proxy_set_header X-Real-IP \\$remote_addr; proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for; } } runcmd: - systemctl restart nginx provision_solution.sh\n#!/bin/bash # Variables RESOURCE_GROUP=\u0026#34;DemoRG\u0026#34; LOCATION=\u0026#34;northeurope\u0026#34; VNET_NAME=\u0026#34;DemoVNet\u0026#34; SUBNET_NAME=\u0026#34;default\u0026#34; NSG_NAME=\u0026#34;DemoNSG\u0026#34; ASG_REVERSE_PROXY=\u0026#34;ReverseProxyASG\u0026#34; ASG_BASTION_HOST=\u0026#34;BastionHostASG\u0026#34; WEB_SERVER=\u0026#34;WebServer\u0026#34; REVERSE_PROXY=\u0026#34;ReverseProxy\u0026#34; BASTION_HOST=\u0026#34;BastionHost\u0026#34; # Create Resource Group echo \u0026#34;Creating Resource Group...\u0026#34; az group create --name $RESOURCE_GROUP --location $LOCATION # Create Virtual Network and Subnet echo \u0026#34;Creating Virtual Network and Subnet...\u0026#34; az network vnet create \\ --resource-group $RESOURCE_GROUP \\ --name $VNET_NAME \\ --address-prefix 10.0.0.0/16 \\ --subnet-name $SUBNET_NAME \\ --subnet-prefix 10.0.0.0/24 # Create Application Security Groups echo \u0026#34;Creating Application Security Groups...\u0026#34; az network asg create \\ --resource-group $RESOURCE_GROUP \\ --name $ASG_REVERSE_PROXY az network asg create \\ --resource-group $RESOURCE_GROUP \\ --name $ASG_BASTION_HOST # Create Network Security Group echo \u0026#34;Creating Network Security Group...\u0026#34; az network nsg create \\ --resource-group $RESOURCE_GROUP \\ --name $NSG_NAME # Create NSG Rules echo \u0026#34;Adding SSH and HTTP rules to NSG...\u0026#34; az network nsg rule create \\ --resource-group $RESOURCE_GROUP \\ --nsg-name $NSG_NAME \\ --name AllowSSH \\ --priority 1000 \\ --access Allow \\ --protocol Tcp \\ --direction Inbound \\ --source-address-prefixes Internet \\ --source-port-ranges \u0026#34;*\u0026#34; \\ --destination-asg $ASG_BASTION_HOST \\ --destination-port-ranges 22 az network nsg rule create \\ --resource-group $RESOURCE_GROUP \\ --nsg-name $NSG_NAME \\ --name AllowHTTP \\ --priority 2000 \\ --access Allow \\ --protocol Tcp \\ --direction Inbound \\ --source-address-prefixes Internet \\ --source-port-ranges \u0026#34;*\u0026#34; \\ --destination-asg $ASG_REVERSE_PROXY \\ --destination-port-ranges 80 # Associate NSG with Subnet echo \u0026#34;Associating NSG with Subnet...\u0026#34; az network vnet subnet update \\ --resource-group $RESOURCE_GROUP \\ --vnet-name $VNET_NAME \\ --name $SUBNET_NAME \\ --network-security-group $NSG_NAME # Create Web Server VM echo \u0026#34;Creating Web Server VM...\u0026#34; az vm create \\ --resource-group $RESOURCE_GROUP \\ --name $WEB_SERVER \\ --image Ubuntu2204 \\ --size Standard_B1s \\ --admin-username azureuser \\ --vnet-name $VNET_NAME \\ --subnet $SUBNET_NAME \\ --nsg \u0026#34;\u0026#34; \\ --public-ip-address \u0026#34;\u0026#34; \\ --generate-ssh-keys \\ --custom-data @web_server_config.yaml # Create Reverse Proxy VM echo \u0026#34;Creating Reverse Proxy VM...\u0026#34; az vm create \\ --resource-group $RESOURCE_GROUP \\ --name $REVERSE_PROXY \\ --image Ubuntu2204 \\ --size Standard_B1s \\ --admin-username azureuser \\ --vnet-name $VNET_NAME \\ --subnet $SUBNET_NAME \\ --nsg \u0026#34;\u0026#34; \\ --generate-ssh-keys \\ --custom-data @reverse_proxy_config.yaml # Create Bastion Host VM echo \u0026#34;Creating Bastion Host VM...\u0026#34; az vm create \\ --resource-group $RESOURCE_GROUP \\ --name $BASTION_HOST \\ --image Ubuntu2204 \\ --size Standard_B1s \\ --admin-username azureuser \\ --vnet-name $VNET_NAME \\ --subnet $SUBNET_NAME \\ --nsg \u0026#34;\u0026#34; \\ --generate-ssh-keys # Attach ASGs to NIC IP Configurations echo \u0026#34;Attaching ASGs to NICs...\u0026#34; # Get NIC IDs REVERSE_PROXY_NIC_ID=$(az vm show --resource-group $RESOURCE_GROUP --name $REVERSE_PROXY --query \u0026#39;networkProfile.networkInterfaces[0].id\u0026#39; --output tsv) BASTION_HOST_NIC_ID=$(az vm show --resource-group $RESOURCE_GROUP --name $BASTION_HOST --query \u0026#39;networkProfile.networkInterfaces[0].id\u0026#39; --output tsv) # Extract NIC Names REVERSE_PROXY_NIC_NAME=$(basename $REVERSE_PROXY_NIC_ID) BASTION_HOST_NIC_NAME=$(basename $BASTION_HOST_NIC_ID) # Get the NIC IP Configurations REVERSE_PROXY_NIC_IP_CONFIG=$(az network nic show --resource-group $RESOURCE_GROUP --name $REVERSE_PROXY_NIC_NAME --query \u0026#39;ipConfigurations[0].name\u0026#39; --output tsv) BASTION_HOST_NIC_IP_CONFIG=$(az network nic show --resource-group $RESOURCE_GROUP --name $BASTION_HOST_NIC_NAME --query \u0026#39;ipConfigurations[0].name\u0026#39; --output tsv) # Attach ASG to Reverse Proxy NIC az network nic ip-config update \\ --resource-group $RESOURCE_GROUP \\ --nic-name $REVERSE_PROXY_NIC_NAME \\ --name $REVERSE_PROXY_NIC_IP_CONFIG \\ --application-security-groups $ASG_REVERSE_PROXY # Attach ASG to Bastion Host NIC az network nic ip-config update \\ --resource-group $RESOURCE_GROUP \\ --nic-name $BASTION_HOST_NIC_NAME \\ --name $BASTION_HOST_NIC_IP_CONFIG \\ --application-security-groups $ASG_BASTION_HOST echo \u0026#34;Provisioning Complete!\u0026#34; "},{"id":6,"href":"/docs/2.-exercises/1.-presentation-layer/4.-client-side-validation-with-data-annotations/","title":"4. Data Annotations and Client-Side Validation","section":"1. Presentation Layer","content":" Data Annotations and Client-Side Validation # Goal # Enhance the existing form by introducing data annotations for client-side validation to improve user experience and enforce input constraints.\nLearning Objectives # By the end of this exercise, you will:\nUse data annotations ([Required], [EmailAddress], [StringLength]) Enable client-side validation using ASP.NET Core built-in validation Improve form feedback with validation messages Step-by-Step Instructions # Step 1: Update the Model with Data Annotations # Open Subscriber.cs in the Models folder. Add validation attributes to enforce required fields and format constraints. Models/Subscriber.cs\nusing System.ComponentModel.DataAnnotations; namespace CloudSoft.Models; public class Subscriber { [Required] [StringLength(20, ErrorMessage = \u0026#34;Name cannot exceed 20 characters\u0026#34;)] public string? Name { get; set; } [Required] [EmailAddress] public string? Email { get; set; } } Information\n[Required] ensures the field must be filled. [StringLength] limits the length of the Name field. [EmailAddress] ensures a valid email format. Step 2: Update the View to Display Validation Messages # Open Views/Newsletter/Subscribe.cshtml. Add validation messages for form fields. Views/Newsletter/Subscribe.cshtml\n@model CloudSoft.Models.Subscriber @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Newsletter Signup\u0026#34;; } \u0026lt;h2\u0026gt;Newsletter Signup\u0026lt;/h2\u0026gt; @if (ViewBag.Message != null) { \u0026lt;p style=\u0026#34;color: green;\u0026#34;\u0026gt;@ViewBag.Message\u0026lt;/p\u0026gt; } \u0026lt;form asp-action=\u0026#34;Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Name\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Name\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Email\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Email\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Email\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; @section Scripts { \u0026lt;partial name=\u0026#34;_ValidationScriptsPartial\u0026#34; /\u0026gt; } Information\nThe asp-validation-for displays validation errors next to fields. _ValidationScriptsPartial enables client-side validation using jQuery. Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Try submitting the form with missing or invalid data.\nEnsure error messages appear and prevent submission.\nFill in valid data and confirm successful submission.\nShout Out! 🎉 # Fantastic job! You\u0026rsquo;ve successfully added data validation and client-side validation 🚀\n"},{"id":7,"href":"/docs/2.-exercises/1.-presentation-layer/5.-server-side-validation/","title":"5. Server-Side Validation and Improved Feedback","section":"1. Presentation Layer","content":" Server-Side Validation and Improved Feedback # Goal # Enhance the form by introducing server-side validation, managing a list of subscribers, and improving feedback handling using TempData and model-level errors.\nLearning Objectives # By the end of this exercise, you will:\nImplement server-side validation for better security. Store subscribers in a list within the controller. Use regular expressions to validate email format. Prevent duplicate email signups. Replace ViewBag with TempData for better feedback persistence. Use ModelState.AddModelError to improve error handling. Step-by-Step Instructions # Step 1: Update the Model with Server-Side Validation # Open Subscriber.cs in the Models folder. Improve client-side email validation using regular expressions. Models/Subscriber.cs\nusing System.ComponentModel.DataAnnotations; namespace CloudSoft.Models; public class Subscriber { [Required] [StringLength(20, ErrorMessage = \u0026#34;Name cannot exceed 20 characters\u0026#34;)] public string? Name { get; set; } [Required] [EmailAddress] [RegularExpression(\u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\u0026#34;, ErrorMessage = \u0026#34;Missing top level domain\u0026#34;)] public string? Email { get; set; } } Information # The RegularExpression attribute enforces stricter email format validation. This prevents malformed or suspicious email input. Step 2: Update the Controller to Store Subscribers and Prevent Duplicates # Open NewsletterController.cs. Modify the Subscribe method to check for duplicate emails and store data in memory. Controllers/NewsletterController.cs\nusing System.Text.RegularExpressions; using CloudSoft.Models; using Microsoft.AspNetCore.Mvc; namespace CloudSoft.Controllers; public class NewsletterController : Controller { // Create a \u0026#34;database\u0026#34; of subscribers for demonstration purposes private static List\u0026lt;Subscriber\u0026gt; _subscribers = []; [HttpGet] public IActionResult Subscribe() { return View(); } [HttpPost] public IActionResult Subscribe(Subscriber subscriber) { // Validate the model if (!ModelState.IsValid) { return View(subscriber); } // Check if the email is already subscribed and return a general model level error if (_subscribers.Any(s =\u0026gt; s.Email == subscriber.Email)) { ModelState.AddModelError(\u0026#34;Email\u0026#34;, \u0026#34;The email is already subscribed. Please use a different email.\u0026#34;); return View(subscriber); } // Add the subscriber to the list _subscribers.Add(subscriber); // Write to the console Console.WriteLine($\u0026#34;New subscription - Name: {subscriber.Name} Email: {subscriber.Email}\u0026#34;); // Send a message to the user TempData[\u0026#34;SuccessMessage\u0026#34;] = $\u0026#34;Thank you for subscribing, {subscriber.Name}! You will receive our newsletter at {subscriber.Email}\u0026#34;; // Return the view (using the POST-REDIRECT-GET pattern) return RedirectToAction(nameof(Subscribe)); // use nameof() to find the action by name during compile time } } Information\n_subscribers list stores all registered users in memory. Checks if the email already exists before allowing submission. Uses ModelState.AddModelError for field-specific error messages. TempData replaces ViewBag for better feedback persistence across redirects. Step 3: Update the View to Display Errors and TempData Feedback # Open Views/Newsletter/Subscribe.cshtml. Modify the form to display server-side validation errors and TempData messages. Views/Newsletter/Subscribe.cshtml\n@model CloudSoft.Models.Subscriber @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Newsletter Signup\u0026#34;; } \u0026lt;h2\u0026gt;Newsletter Signup\u0026lt;/h2\u0026gt; \u0026lt;!-- Display validation summary for model-level errors --\u0026gt; @if (!ViewData.ModelState.IsValid) { \u0026lt;div class=\u0026#34;alert alert-danger alert-dismissible fade show\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; @Html.ValidationSummary(false, null, new { @class = \u0026#34;text-danger\u0026#34; }) \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn-close\u0026#34; data-bs-dismiss=\u0026#34;alert\u0026#34; aria-label=\u0026#34;Close\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-times\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;!-- Display message from the TempData sent by the controller --\u0026gt; @if (TempData[\u0026#34;SuccessMessage\u0026#34;] != null) { \u0026lt;div class=\u0026#34;alert alert-success alert-dismissible fade show\u0026#34; role=\u0026#34;alert\u0026#34;\u0026gt; @TempData[\u0026#34;SuccessMessage\u0026#34;] \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn-close\u0026#34; data-bs-dismiss=\u0026#34;alert\u0026#34; aria-label=\u0026#34;Close\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-times\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;form asp-action=\u0026#34;Subscribe\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Name\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Name\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label asp-for=\u0026#34;Email\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input asp-for=\u0026#34;Email\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;span asp-validation-for=\u0026#34;Email\u0026#34; class=\u0026#34;text-danger\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-3\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Sign Up\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; @section Scripts { \u0026lt;partial name=\u0026#34;_ValidationScriptsPartial\u0026#34; /\u0026gt; } Information # TempData message is displayed when redirecting after a successful submission. asp-validation-for displays field-specific validation errors. _ValidationScriptsPartial enables client-side validation. Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Try submitting invalid or empty input and confirm error messages.\nTry registering with the same email twice and confirm the duplicate warning.\nSubmit valid data and check if feedback persists correctly using TempData.\nShout Out! 🎉 # Awesome work! You\u0026rsquo;ve implemented server-side validation, handled duplicate entries, and improved feedback management. 🚀\n"},{"id":8,"href":"/docs/2.-exercises/1.-presentation-layer/6.-display-a-list-of-subscribers/","title":"6. Displaying a List of Subscribers","section":"1. Presentation Layer","content":" Goal # Enhance the application by adding a new view to list all subscribers and updating the navigation bar to include a button linking to the new page.\nLearning Objectives # By the end of this exercise, you will:\nCreate a new view to display a list of subscribers. Modify the controller to pass subscriber data to the view. Update the navigation bar to provide access to the new page. Step-by-Step Instructions # Step 1: Update the Controller to Provide Subscriber Data # Open NewsletterController.cs. Add a new action method to return a list of subscribers to the view. Controllers/NewsletterController.cs\n... [HttpGet] public IActionResult Subscribers() { return View(_subscribers); } ... Information\nSubscribers() action returns the list of subscribers to the view. The list is retrieved from the in-memory static list. Step 2: Create the Subscriber List View # Navigate to the Views/Newsletter/ folder. Create a new file named Subscribers.cshtml. Add the following code to display subscribers in a table. Views/Newsletter/Subscribers.cshtml\n@model List\u0026lt;CloudSoft.Models.Subscriber\u0026gt; @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Subscriber List\u0026#34;; } \u0026lt;h2\u0026gt;Subscriber List\u0026lt;/h2\u0026gt; @if (Model.Count == 0) { \u0026lt;p\u0026gt;No subscribers yet.\u0026lt;/p\u0026gt; } else { \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Email\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var subscriber in Model) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;@subscriber.Name\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@subscriber.Email\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; } Information\nDisplays all subscribers in a table. If no subscribers exist, it shows a fallback message. Step 3: Add a Navigation Button to the Navbar # Open Views/Shared/_Layout.cshtml. Add a new navigation link to the Subscriber List page. Views/Shared/_Layout.cshtml\n... \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link text-dark\u0026#34; asp-area=\u0026#34;\u0026#34; asp-controller=\u0026#34;Newsletter\u0026#34; asp-action=\u0026#34;Subscribers\u0026#34;\u0026gt;Subscribers\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; ... Information\nAdds a navigation button to access the Subscriber List page. Final Tests # Run the Application and Validate Your Work # Start the application:\ndotnet run Open a browser and navigate to:\nhttp://localhost:5000/Newsletter/Subscribe Subscribe with multiple names and emails.\nClick Subscribers in the navbar to view the subscriber list.\nEnsure all submitted data appears correctly in the table.\nShout Out! 🎉 # Great job! You\u0026rsquo;ve successfully added a subscriber list page and a navigation button to improve user experience! 🚀\n"}]